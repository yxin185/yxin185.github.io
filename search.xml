<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机基础问题-操作系统</title>
    <url>/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>计算机基础问题-操作系统</p>
<a id="more"></a>



<h2 id="1-进程之间有哪些通信方式"><a href="#1-进程之间有哪些通信方式" class="headerlink" title="1.进程之间有哪些通信方式"></a>1.进程之间有哪些通信方式</h2><p><strong>进程同步：</strong>控制多个进程按一定的顺序执行；</p>
<p><strong>进程通信：</strong>进程间传输信息</p>
<p><strong>进程通信是一种手段，而进程同步是一种目的。即为了能够达到进程同步的目的，需要让进程进行通信。</strong></p>
<ol>
<li><strong>管道</strong><ol>
<li>只支持<strong>半双工</strong>通信</li>
<li>只能在父子进程或兄弟进程中使用</li>
</ol>
</li>
<li><strong>FIFO（命名管道）</strong><ol>
<li>常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传输信息</li>
<li><strong>效率低</strong>下，实现<strong>简单</strong></li>
</ol>
</li>
<li><strong>消息队列</strong><ol>
<li><strong>独立于读写进程</strong>存在，避免了FIFO中同步管道的打开和关闭时可能产生的困难；</li>
<li><strong>避免了FIFO的同步阻塞</strong>问题，不需要进程自己提高同步方法</li>
<li>读进程可以根据消息类型有选择地接收消息，不像FIFO那样只能默认接收</li>
<li><strong>不适合发送数据很大</strong>的情况</li>
</ol>
</li>
<li><strong>信号量（Semaphore)</strong><ol>
<li>一个计数器，用于为多个进程提供对共享数据对象的访问</li>
</ol>
</li>
<li><strong>共享存储</strong><ol>
<li>允许多个进程共享一个给定的存储区</li>
<li>需要使用信号量用来同步对共享存储的访问</li>
<li>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存</li>
<li>系统加载一个进程的时候，分配给进程的内存并不是<strong>实际物理内存</strong>，而是<strong>虚拟内存空间</strong>。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了<strong>内存共享</strong>机制了</li>
</ol>
</li>
<li><strong>套接字（Socket）</strong><ol>
<li>可用于不同机器间的进程通信</li>
</ol>
</li>
<li><strong>总结：</strong> 共有6种通信方式，其中，<strong>管道</strong> 和 <strong>FIFO</strong> 属于同一类管道类。</li>
</ol>
<h2 id="2-经典的进程调度算法"><a href="#2-经典的进程调度算法" class="headerlink" title="2. 经典的进程调度算法"></a>2. 经典的进程调度算法</h2><p>参考来源：<a href="https://mp.weixin.qq.com/s?__biz=MzUyMzU5ODczNA==&mid=2247483688&idx=1&sn=662216279b28c21366d8bcaa1f9e8d21&chksm=fa3b6fc9cd4ce6df357cd7a89265406b7c6febfc559d2fdace0f88006b782df05674db7c5671&scene=21#wechat_redirect" target="_blank" rel="noopener">进程调度，一个调度器的自白</a></p>
<blockquote>
<p> 进程是资源分配的基本单位，进程调度器负责计算机内所有进程的调度，为进程们分配CPU资源。</p>
</blockquote>
<h3 id="1-FCFS（First-Come-First-Serve）先来先服务调度算法"><a href="#1-FCFS（First-Come-First-Serve）先来先服务调度算法" class="headerlink" title="1. FCFS（First Come First Serve）先来先服务调度算法"></a>1. FCFS（First Come First Serve）先来先服务调度算法</h3><ol>
<li>最初的一种进程调度算法，既可以用于作业调度，也能用于进程调度；</li>
<li><strong>在作业调度中：</strong> 每次从<strong>后备作业队列</strong>中选择最先到来的作业进入内存，分配必要的资源，创建进程并进入就绪队列</li>
<li><strong>在进程调度中：</strong> 每次从<strong>就绪队列</strong>中选择最先进入的进程，将处理机分配给他，使其运行，直到 <strong>运行完毕</strong> 或某种原因而阻塞时才释放处理机。</li>
<li><strong>FCFS</strong> 简单，效率低。对长作业（进程）比较有利，相应的，对于短作业（进程）而言，举个较为极端的栗子，他等待了10000年，却只执行了1秒钟。有利于 CPU 繁忙型作业，不适用于I/O繁忙型作业。</li>
<li>不能作为分时系统和实时系统的主要调度策略，经常和其他结合使用（和优先级调度算法结合使用）。</li>
</ol>
<p>有了上述对于短作业（进程）的痛点，调度算法进行了改进；如下</p>
<h3 id="2-SJF（Shortest-Job-First-SPF-Shortest-Process-First"><a href="#2-SJF（Shortest-Job-First-SPF-Shortest-Process-First" class="headerlink" title="2.SJF（Shortest Job First)  /   SPF (Shortest Process First)"></a>2.SJF（Shortest Job First)  /   SPF (Shortest Process First)</h3><ol>
<li><strong>SJF ：</strong>从后备队列中选择<strong>一个或若干个</strong>估计运行时间最短的作业，调入内存运行；</li>
<li><strong>SPF ：</strong>从就绪队列中选择<strong>一个</strong>估计运行时间最短的进程，将处理机分配给他，使之立即运行。</li>
<li>该算法解决了 FCFS 中对于短作业（进程）等待时间很长，运行时间很短的问题，但是也带来了新的问题；</li>
<li>如果后备队列中源源不断的进入预估运行时间短的作业，那么原有的那些预估运行时间长的作业就迟迟得不到运行，极端一点，就会导致长作业被<strong>“饿死”</strong>，即长时间得不到调度。长进程同理，也会出现<strong>“饥饿”</strong> 情况。</li>
<li>该算法<strong>没有考虑作业的紧迫程度</strong>，不能保证紧迫作业能被及时处理（这个问题可以被 <strong>优先级调度算法</strong> 解决）</li>
<li>由于作业的长度是由用户所提供的估计执行时间而定，所以不一定能真正做到短作业（进程）优先调度。</li>
</ol>
<p>有了 FCFS 和 SJF 后，出现了新的<strong>综合考虑二者（既照顾长作业，由照顾短作业）</strong>的调度算法出现，如下：</p>
<h3 id="3-高响应比优先调度算法"><a href="#3-高响应比优先调度算法" class="headerlink" title="3. 高响应比优先调度算法"></a>3. 高响应比优先调度算法</h3><ol>
<li><p><strong>主要用于作业调度</strong></p>
</li>
<li><p>是 FCFS 和 SJF 的综合平衡：<strong>同时考虑每个作业的等待时间和预估运行时间</strong>，在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，选择响应比最高的作业投入运行。响应比公式如下：</p>
<p>​                                                   <code>响应比Rp = (等待时间 + 要求服务时间)  / 要求服务时间</code></p>
</li>
<li><p>根据上述公式，我们可以得到如下结论：</p>
<ol>
<li>作业等待时间相同的时候，要求服务时间越短，响应比越高，有利于短作业</li>
<li>要求服务时间相同的时候，等待时间越长，响应比越高，此时就是 FCFS</li>
<li>对于长作业，作业的响应比可以随着等待时间的增加而提高，当其等待时间足够长时，响应比就很大，从而可以获得处理机，克服了 <strong>“饥饿”</strong> 的情况，兼顾了长作业。</li>
</ol>
</li>
</ol>
<h3 id="4-时间片轮转算法"><a href="#4-时间片轮转算法" class="headerlink" title="4.时间片轮转算法"></a>4.时间片轮转算法</h3><ol>
<li><strong>适用于分时系统</strong></li>
<li>系统将所有的就绪进程按到达时间排成一个队列，进程调度程序总是选择队列头的进程运行，并<strong>开启定时器</strong>，即一个时间片。一个时间片用完之后，该进程被迫<strong>“下机”</strong> 进入队列尾<strong>排队等待下一次循环到队列头</strong>。下一个进程还是选择当前的队列头，即 FCFS，因为是按照到达时间排队的。</li>
<li>时间片的大小对系统性能影响较大<ol>
<li>如果时间片足够大，以至于队列中所有进程都能在一个时间片内运行完毕，那么就退化成一个 FCFS 了；</li>
<li>如果时间片很小，单位时间可以运行的进程从直观上来说就会越多，<strong>但是</strong>，此时处理机就会在进程间频繁切换，进程的频繁切换会导致大量CPU资源浪费（上下文切换产生开销），使处理机开销增大。</li>
</ol>
</li>
<li>时间片长短的决定因素：<strong>系统的响应时间</strong>，<strong>就绪队列中的进程数目</strong>以及<strong>系统的处理能力</strong>。</li>
</ol>
<h3 id="5-优先级调度算法"><a href="#5-优先级调度算法" class="headerlink" title="5. 优先级调度算法"></a>5. 优先级调度算法</h3><ol>
<li>可用于作业调度和进程调度；</li>
<li>优先级高的先运行，每次都选择优先级最高的作业（进程）来运行</li>
<li>根据新的最高优先级进程能否抢占正在运行的进程，又可以分为<ol>
<li><strong>非剥夺式优先级调度算法：</strong>等待前一个运行的进程运行结束最新高优先级才运行</li>
<li><strong>剥夺式优先级调度算法：</strong> 不管三七二十一，立即停止当前正在运行的进程，运行更重要或紧迫的进程</li>
</ol>
</li>
<li>根据进程创建后优先级是否可以改变，又可以分为：<ol>
<li><strong>静态优先级：</strong>优先级在创建时确定，在运行时不变。主要依据：<strong>进程类型、进程对资源的需求、用户要求</strong></li>
<li><strong>动态优先级：</strong> 优先级动态变化，为保证低优先级不被<strong>“饿死”</strong>， 低优先级随时间增加，优先级可以逐步升高。主要依据：<strong>进程占用CPU的时间的长度、就绪进程等待CPU时间的长短</strong>。</li>
</ol>
</li>
</ol>
<h3 id="6-多级反馈队列调度算法（结合前五种的优点）"><a href="#6-多级反馈队列调度算法（结合前五种的优点）" class="headerlink" title="6.多级反馈队列调度算法（结合前五种的优点）"></a>6.多级反馈队列调度算法（结合前五种的优点）</h3><ol>
<li>是时间片轮转算法和优先级调度算法的综合和发展；</li>
<li>动态调整进程优先级和时间片大小</li>
<li>如下优点：<ol>
<li>终端型作业用户：短作业优先</li>
<li>短批处理作业用户：周转时间较短</li>
<li>长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。</li>
</ol>
</li>
</ol>
<h2 id="3-用户级线程和内核级线程"><a href="#3-用户级线程和内核级线程" class="headerlink" title="3.用户级线程和内核级线程"></a>3.用户级线程和内核级线程</h2><p>参考来源：<a href="https://mp.weixin.qq.com/s?__biz=MzUyMzU5ODczNA==&mid=2247483712&idx=1&sn=18e53f3d77a32d8aa9eb57adb2e05f86&chksm=fa3b6fa1cd4ce6b7987923efba596c1467362239d32851c0f175d56627405e6a31fdfa56922f&scene=21#wechat_redirect" target="_blank" rel="noopener">用户级线程和内核级线程有什么区别？</a></p>
<h2 id="4-多线程模型"><a href="#4-多线程模型" class="headerlink" title="4.多线程模型"></a>4.多线程模型</h2><blockquote>
<p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%86%85%E6%A0%B8%E7%BA%A7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%A7.png" alt="多线程模型"></p>
<ol>
<li><strong>多对一模型：（a)</strong> 将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。用户级线程对操作系统不可见（即透明）<ol>
<li><strong>优点：</strong>线程管理在用户空间完成，效率高</li>
<li><strong>缺点：</strong>当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行运行在多个处理机上。</li>
</ol>
</li>
<li><strong>一对一模型：（b）</strong> 每个用户线程对应一个内核级线程<ol>
<li><strong>优点：</strong> 当一个线程被阻塞后，其他线程还能正常执行，因此并发性能好；</li>
<li><strong>缺点：</strong> 每创建一个用户级线程都要创建一个对应的内核级线程与之对应，开销较大，会影响到应用程序的性能。</li>
</ol>
</li>
<li><strong>多对多模型：(C)</strong> 将 n 个用户级线程对应到 m 个内核级线程。<code>n &gt;= m</code> <ol>
<li>特点：是前两种模型取了一个折中。集两者之所长。</li>
</ol>
</li>
</ol>
<h2 id="5-线程的来源"><a href="#5-线程的来源" class="headerlink" title="5.线程的来源"></a>5.线程的来源</h2><p>参考来源：<a href="https://mp.weixin.qq.com/s?__biz=MzUyMzU5ODczNA==&mid=2247483706&idx=1&sn=1b806a9e3cc29b8050ae0eaa15eb5d8f&chksm=fa3b6fdbcd4ce6cdd75291ac7632aea482b0f87901f5856a5c396ab27dcf57625f0f6e9ed8d3&scene=21#wechat_redirect" target="_blank" rel="noopener">线程的来龙去脉</a></p>
<h2 id="6-互斥"><a href="#6-互斥" class="headerlink" title="6.互斥"></a>6.互斥</h2><p>参考来源：<a href="https://mp.weixin.qq.com/s?__biz=MzUyMzU5ODczNA==&mid=2247483748&idx=1&sn=b07031e0e2f34ad1529e9b2d86a369b6&chksm=fa3b6f85cd4ce693476e6dc1b23ee0029794dfc7559cc27e9690a5118ab2bf8ea2b005589d90&scene=21#wechat_redirect" target="_blank" rel="noopener">互斥那点事儿-上</a></p>
<p>参考来源：<a href="https://mp.weixin.qq.com/s?__biz=MzUyMzU5ODczNA==&mid=2247483753&idx=1&sn=595cf7dc086aa37fedf6535675b15c64&chksm=fa3b6f88cd4ce69e9f4b0b9a6608f00b2e5a1e7cebb0ba5e2411efdacbae3586e62f2d85fee0&scene=21#wechat_redirect" target="_blank" rel="noopener">互斥那点事儿-下</a></p>
<h2 id="7-各种锁"><a href="#7-各种锁" class="headerlink" title="7.各种锁"></a>7.各种锁</h2><p>参考来源：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485371&idx=1&sn=d20720183cb10590e88f163f7fa87245&scene=21#wechat_redirect" target="_blank" rel="noopener">一句话撸完重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等各种锁 —- 不看后悔系列</a></p>
]]></content>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见问题-java篇-part3</title>
    <url>/2019/12/08/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-java%E7%AF%87-part3/</url>
    <content><![CDATA[<p>面试常见问题第三部分</p>
<a id="more"></a>

<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1-Java的异常体系"><a href="#1-Java的异常体系" class="headerlink" title="1.Java的异常体系"></a>1.Java的异常体系</h2><p>以 <code>Throwable</code> 为根，分为两大类，分别是<code>Error</code> 和 <code>Exception</code> 。</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" alt></p>
<ol>
<li><code>RuntimeException</code> 的名字有点误导，其实其他异常也是运行时产生的，他表示的实际含义是<strong>未受检异常</strong>，相对而言，其他异常都是<strong>受检异常</strong>，<code>Error</code> 及其子类也是受检异常。</li>
<li>对于<strong>受检异常</strong>，Java 会强制要求程序员去处理，否则会有编译错误，而对于未受检异常，就没有这个限制</li>
</ol>
<h2 id="2-什么是异常链"><a href="#2-什么是异常链" class="headerlink" title="2.什么是异常链"></a>2.什么是异常链</h2><blockquote>
<p>将捕获的异常包装进一个新的异常中并重新抛出的异常处理方式。</p>
</blockquote>
<ol>
<li>首先创建一个自己的异常类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>测试异常链</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionChain</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Test1():抛出 “喝晕了” 异常</span></span><br><span class="line"><span class="comment">     * Test2():调用Test1()，捕获 “喝晕了” 异常，并且包装成运行时异常，继续抛出</span></span><br><span class="line"><span class="comment">     * main() 方法中，调用 Test2()，捕获 Test2() 方法抛出的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"喝车不开酒！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Test1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            RuntimeException newException = <span class="keyword">new</span> RuntimeException(<span class="string">"司机一滴酒，亲人两行泪！"</span>);</span><br><span class="line">            newException.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> newException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExceptionChain ec = <span class="keyword">new</span> ExceptionChain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ec.Test2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行结果</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%BC%82%E5%B8%B8%E9%93%BE%E6%B5%8B%E8%AF%95.png" alt></p>
<h2 id="3-Java-中实现多态的机制是什么"><a href="#3-Java-中实现多态的机制是什么" class="headerlink" title="3.Java 中实现多态的机制是什么"></a>3.Java 中实现多态的机制是什么</h2><p>首先回忆一下什么是多态？</p>
<blockquote>
<p><strong>子类对象赋值给父类变量，但运行时依然表现出子类的行为特征</strong>，意味着同一类型的对象在执行过程中可能表现出不同行为特征。</p>
</blockquote>
<p>记住一句话：<strong>编译看父类，运行看子类。</strong></p>
<p>实现多态的机制：子类继承父类后，对父类的方法可以有两种行为，一种是重载，一种是重写。对于重写（运行时多态，就是真正的多态），使用父类变量调用该方法时，表现出子类重新定义的行为特征；对于重载（编译时多态，不是真正的多态），因为父类中没有这个方法，所以在编译阶段会出错，父类变量无法调用一个在父类中没有的方法。</p>
<p>如果想要调用子类中特有的方法，需要向下转型。</p>
<h2 id="4-说一下泛型原理，并举例说明"><a href="#4-说一下泛型原理，并举例说明" class="headerlink" title="4.说一下泛型原理，并举例说明"></a>4.说一下泛型原理，并举例说明</h2><blockquote>
<p>泛型就是类型参数化，处理的数据类型是不固定的，而是可以作为参数传入的。</p>
</blockquote>
<ol>
<li><p><strong>基本原理</strong></p>
<p>Java 有编译器和虚拟机，编译器将 Java 源代码转换成为 <code>.class</code> 文件，虚拟机加载并允许 <code>.class</code> 文件。<strong>对于泛型类，Java 编译器会将泛型代码转换为普通的非泛型代码，将类型参数 T 擦除，替换为 Object，插入必要的强制类型转换。Java 虚拟机并不知道泛型这一回事儿，只知道普通的类及代码。</strong> </p>
<p><strong>Java 泛型是通过类型擦除来实现的，类定义中的类型参数 T 会被替换成 Object，在程序运行过程中，不知道泛型的实际类型参数，比如 <code>Pair&lt;Integer&gt;</code> ，运行只知道 <code>Pair</code> ，不知道 <code>Integer</code>。</strong></p>
<p>如果指定了泛型的边界，那么在进行泛型擦除的时候，就不会转换成 <code>Object</code>，而是转换为边界类型。</p>
</li>
<li><p>举例说明</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">U</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> U name;</span><br><span class="line">    <span class="keyword">private</span> V age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(U name, V age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> U <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   在经过 Java 编译之后，所以泛型类型 <code>U,V</code> 都转换成 <code>Object</code> 。在之后需要使用到的地方，都需要进行强制类型转换</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">"Hello"</span>, <span class="number">20</span>);</span><br><span class="line">String name = (String)p.getName();</span><br><span class="line">Integer age = (Integer)p.getAge();</span><br></pre></td></tr></table></figure>

<h2 id="5-Java-中-String-的了解"><a href="#5-Java-中-String-的了解" class="headerlink" title="5.Java 中 String 的了解"></a>5.Java 中 String 的了解</h2><ol>
<li><p>了解基本用法，基本的函数调用</p>
</li>
<li><p>String 内部使用一个字符数组表示字符串，实例变量定义为：（JDK 1.9 之前）</p>
<p><code>private final char value[];</code> </p>
</li>
<li><p>从 JDK 1.9 开始，内部使用一个字节数组来表示字符串，实例变量定位为：</p>
<p><code>private final byte value[];</code> 使用字节数组，如果字符都是 ASCII 字符，他就可以使用一个字节表示一个字符，而不是 UTF-16BE 编码，节省空间；</p>
</li>
<li><p>不可变性，一旦创建就不可变；</p>
</li>
<li><p>常量字符串，可以参考 part2 部分关于 <code>String.intern();</code> 方法的讲解。</p>
</li>
<li><p>重写 hashCode 方法，参考 part1 关于 hashCode 的讲解。</p>
</li>
<li><p>运用在正则表达式中</p>
</li>
</ol>
<h2 id="6-String-为什么要设计成不可变的？"><a href="#6-String-为什么要设计成不可变的？" class="headerlink" title="6.String 为什么要设计成不可变的？"></a>6.String 为什么要设计成不可变的？</h2><ol>
<li>保证安全；</li>
<li>保证性能；</li>
<li>线程安全</li>
</ol>
<h2 id="7-序列化的方式"><a href="#7-序列化的方式" class="headerlink" title="7.序列化的方式"></a>7.序列化的方式</h2><blockquote>
<p>序列化就是将对象转换为字节流，反序列化就是将字节流转换为对象。</p>
</blockquote>
<ol>
<li><strong>基本用法</strong></li>
</ol>
<p>要让一个类支持序列化，要让他实现一个接口<code>java.io.Serializable</code> 。对于一个学生类，我们可以如下操作使其支持序列化<code>public class Student implement Serializable{ // 省略}</code> 。声明之后，保存/读取<code>Student</code> 对象就可以通过使用 <code>ObjectOutputStream/ObjectInputStream</code> 流了。<code>ObjectOutputStream</code> 是 <code>OutputStream</code> 的子类，但是实现了<code>ObjectOutput</code> 接口。<code>ObjectOutput</code> 是 <code>DataOutput</code> 的子接口，增加一个方法<code>public void writeObject(Object obj) throws IOException</code> 。<code>ObjectInputStream</code> 同理，增加一个方法<code>public void readObject() throws ClassNotFoundException, IOException</code> 。</p>
<ul>
<li>保存学生列表的代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeStudents</span><span class="params">(List&lt;Student&gt; students)</span> </span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">    	<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"students.dat"</span>)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//out.writeInt(students.size());</span></span><br><span class="line">        <span class="comment">//for (Student s : students) &#123;</span></span><br><span class="line">        <span class="comment">//    out.writeObject(s);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        out.writeObject(students);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从文件中读入学生列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title">readStudents</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">    	<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"students.dat"</span>)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//int size = in.readInt();</span></span><br><span class="line">        <span class="comment">//List&lt;Student&gt; list = new ArrayList&lt;&gt;(size);</span></span><br><span class="line">        <span class="comment">//for (int i = 0;i &lt; size;i ++) &#123;</span></span><br><span class="line">        <span class="comment">//    list.add( (Student) in.readObject());</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return list;</span></span><br><span class="line">        <span class="keyword">return</span> (List&lt;Student&gt; in.readObject());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-如何格式化日期"><a href="#8-如何格式化日期" class="headerlink" title="8.如何格式化日期?"></a>8.如何格式化日期?</h2><p>在 Java 8 中，主要的格式化类是<code>java.time.format.DateTimeFormatter</code> ，他是<strong>线程安全</strong>的。之前用的 <code>java.text.SimpleDateFormat</code> <strong>不是线程安全</strong>的。</p>
<ol>
<li>看一段代码，演示基本使用方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateOperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        LocalDateTime ldt = LocalDateTime.of(<span class="number">2019</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">29</span>,<span class="number">30</span>);</span><br><span class="line">        System.out.println(formatter.format(ldt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 2019-12-06 21:29:30</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>也可以将字符串转换为日期和时间对象，可以使用对应类的 <code>parse</code> 方法，如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateOperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">"2019-12-06 21:29:30"</span>;</span><br><span class="line">        str2DateTime(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">str2DateTime</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        LocalDateTime ldt = LocalDateTime.parse(string, formatter);</span><br><span class="line">        System.out.println(ldt.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 2019-12-06T21:29:30</span></span><br></pre></td></tr></table></figure>

<h2 id="9-静态代理和动态代理的区别，什么场景使用？"><a href="#9-静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="9.静态代理和动态代理的区别，什么场景使用？"></a>9.静态代理和动态代理的区别，什么场景使用？</h2><p> 参考：<a href="https://blog.csdn.net/hejingyuan6/article/details/36203505" target="_blank" rel="noopener">JAVA学习篇–静态代理VS动态代理</a></p>
<blockquote>
<p><strong>动态代理：</strong> 一种强大的功能，他可以在运行时动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为。是<strong>面向切面编程（AOP）</strong>的基础。有两种方式，一种是 Java SDK 提供的，还有一种是第三方库如 cglib。</p>
</blockquote>
<ol>
<li><p><strong>静态代理：</strong>由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的<code>.class</code> 文件就已经存在</p>
<ol>
<li><strong>优点：</strong>代理使客户端不需要知道实现类是什么，怎么做的，只需要知道代理即可。</li>
<li><strong>缺点：</strong> 代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法，出现大量的重复代码</li>
<li><strong>缺点：</strong> 代理对象只服务于一种类型的对象，如果要服务多类型的对象，就需要为每一种对象都进行代理</li>
<li><strong>静态代理类只能为特定的接口服务 ，如果想要为多个接口服务就要建立很多个代理类</strong></li>
</ol>
</li>
<li><p><strong>动态代理：</strong> 在程序员运行时运用反射机制动态创建而成。</p>
<ol>
<li>与静态代理相比，最大的优点就是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理<code>InvocationHandler.invoke</code> 。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。类职责更加单一，复用性更强。</li>
<li><strong>使用静态代理，可以编写通用的代理逻辑，用于各种类型的被代理对象，而不需要为每一个被代理的类型都创建一个静态代理。</strong></li>
</ol>
</li>
</ol>
<h2 id="10-反射的原理，反射创建类实例的三种方式是什么"><a href="#10-反射的原理，反射创建类实例的三种方式是什么" class="headerlink" title="10.反射的原理，反射创建类实例的三种方式是什么"></a>10.反射的原理，反射创建类实例的三种方式是什么</h2><h3 id="1-反射的原理"><a href="#1-反射的原理" class="headerlink" title="1.反射的原理"></a>1.反射的原理</h3><blockquote>
<p><strong>每个已加载的类在内存中都有一份类信息，每个对象都有指向它所属类信息的引用。类信息对应的类就是<code>java.lang.Class</code> 。</strong></p>
</blockquote>
<h3 id="2-三种方式"><a href="#2-三种方式" class="headerlink" title="2.三种方式"></a>2.三种方式</h3><ol>
<li><p>使用 <code>Object</code> 类中的 <code>getClass()</code> 方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">Class stuClass = stu.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>任何数据类型（包括基本数据类型）都有一个 “静态” 的 <code>class</code> 属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">Class stuClass2 = Student.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>Class</code> 类的静态方法：</strong> <code>forName(String className)</code> <strong>（常用）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class stuClass3 = Class.forName(<span class="string">"包名.Student"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="11-说说对-Java-反射的理解"><a href="#11-说说对-Java-反射的理解" class="headerlink" title="11.说说对 Java 反射的理解"></a>11.说说对 Java 反射的理解</h2><p>​    反射是指在运行时，程序可以动态获取类型的信息，比如接口信息、成员信息、方法信息、构造方法信息等，根据这些动态获取的信息创建对象、访问或修改对象，调用方法。</p>
<p><strong>反射就是把Java类中的各种成分映射成一个个的Java对象</strong></p>
<p>Class 对象的由来是将class文件读入内存，并为之创建一个Class对象</p>
<p>参考如图：<a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java 基础之-反射</a></p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%8F%8D%E5%B0%84.png" alt></p>
<h2 id="12-说说对-Java-注解的理解"><a href="#12-说说对-Java-注解的理解" class="headerlink" title="12.说说对 Java 注解的理解"></a>12.说说对 Java 注解的理解</h2><blockquote>
<p>注解就是给程序添加一些信息，用字符 @ 开头，这些信息用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序行为。定制序列化和依赖注入容器。</p>
</blockquote>
<ol>
<li><p>内置注解</p>
<p><code>@Override</code> ,<code>@Deprecated</code> ,<code>@SuppressWarnings(抑制的警告类型)</code>。</p>
</li>
<li><p><strong>定制序列化和依赖注入容器</strong>是两种应用。</p>
</li>
<li><p>注解提升了Java语言的表达能力，有效实现了应用功能和底层功能的分离，框架和库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架或库进行协作。</p>
</li>
<li><p>可以帮助程序员执行基本编译时检查，如<code>@Override</code> 的使用</p>
</li>
<li><p>有四个用于修饰自定义注解的元注解：<code>@Target</code> 表示注解目标， <code>@Retention</code> 表示注解信息保留到什么时候 , <code>@Documented</code> 注解信息包含到生成的文档中,<code>@Inherited</code>  </p>
</li>
</ol>
]]></content>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见问题-java篇-part2</title>
    <url>/2019/12/02/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-java%E7%AF%87-part2/</url>
    <content><![CDATA[<p>面试常见问题第二部分</p>
<a id="more"></a>

<h1 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1.Java基础"></a>1.Java基础</h1><h2 id="11-String-转换成-Integer-的方式及原理"><a href="#11-String-转换成-Integer-的方式及原理" class="headerlink" title="11. String 转换成 Integer 的方式及原理"></a>11. String 转换成 Integer 的方式及原理</h2><ol>
<li><p>使用 Integer 类的 <code>Integer.parseInt()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"17"</span>;</span><br><span class="line">        Integer i = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">boolean</span> res = i.equals(<span class="number">13</span>);</span><br><span class="line">        System.out.println(i);	<span class="comment">// 输出 17</span></span><br><span class="line">        System.out.println(res);	<span class="comment">// 输出 false</span></span><br><span class="line">    	Integer num = Integer.parseInt(s, <span class="number">8</span>);</span><br><span class="line">    	System.out.println(num);	<span class="comment">// 输出 15 = 1 * 8^1 + 7 * 8^0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述方法默认使用十进制解析，也可以传入参数指定将 s 按参数进制解析</p>
<ol>
<li>11 - 22  行进行参数检验，包括<strong>字符串和进制</strong>是否符合要求。<ol>
<li>字符串不为空，否则抛出异常</li>
<li>进制在 [2,36] 之间，否则抛出异常</li>
<li>开始处理字符串，23 行之后<ol>
<li>取字符串第一位字符，根据字符的 ASCII 码与 ‘0’ 比较，判断是不是 ‘+’ 或 ‘-‘</li>
<li>确定正负数后，逐步获取每位字符的 int 值；</li>
<li>通过 *= 和 -= 对各结果进行拼接</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseInt(s,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定基数 radix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * WARNING: This method may be invoked early during VM initialization</span></span><br><span class="line"><span class="comment">     * before IntegerCache is initialized. Care must be taken to not use</span></span><br><span class="line"><span class="comment">     * the valueOf method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                        <span class="string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                        <span class="string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> multmin;</span><br><span class="line">    <span class="keyword">int</span> digit;</span><br><span class="line">	<span class="comment">// 主体思路是首先判断第一位是否是符号，然后逐位转换</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ‘-’ 和 ‘+’ 的ASCII码分别为45和43，都小于字符‘0’的ASCII码48</span></span><br><span class="line">        <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">            <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                negative = <span class="keyword">true</span>;	<span class="comment">// 负数</span></span><br><span class="line">                limit = Integer.MIN_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        multmin = limit / radix;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">            <span class="comment">// 这个方法比较关键，主要作用是根据字符的ASCII码把字符转换成int类型，如字符‘2’，则返回int类型的2，具体分析看下面；</span></span><br><span class="line">            digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">            <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这边就是对返回int作一系列的拼接运算，得到个、百、千位的结果</span></span><br><span class="line">            result *= radix;</span><br><span class="line">            <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result -= digit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="12-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"><a href="#12-静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？" class="headerlink" title="12. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？"></a>12. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</h2><h3 id="1-是否可以被重写？"><a href="#1-是否可以被重写？" class="headerlink" title="1. 是否可以被重写？"></a>1. 是否可以被重写？</h3><ol>
<li><p>我们先看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son1 s = <span class="keyword">new</span> Son1();</span><br><span class="line">        s.printFatherStatic();  <span class="comment">// 输出：子类继承父类静态属性：我是爸爸的静态属性</span></span><br><span class="line">        s.printStaticMethod();  <span class="comment">// 输出：我是父类的静态方法</span></span><br><span class="line">        System.out.println(s.fatherStatic);   <span class="comment">// 输出：我是爸爸的静态属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String fatherStatic = <span class="string">"我是爸爸的静态属性"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是父类的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFatherStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类继承父类静态属性："</span> + fatherStatic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过上面的代码，我们可以看出，子类可以直接使用定义在父类内部的静态属性，也可以调用父类的静态方法，所以说明，<strong>子类可以继承父类的静态属性和静态方法</strong>。</p>
</li>
<li><p><strong>原因：</strong></p>
<ol>
<li>因为静态方法和静态属性在程序开始运行开始后就已经分配了内存，所有引用到该方法和属性的对象所指向的都是同一块内存区域中的数据，也就是该静态方法、静态属性；</li>
</ol>
</li>
</ol>
<h3 id="2-是否可以被重写？"><a href="#2-是否可以被重写？" class="headerlink" title="2.是否可以被重写？"></a>2.是否可以被重写？</h3><ol>
<li>在上述代码的基础上，加上几行，报错！</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99%E5%90%97.png" alt></p>
<ol start="2">
<li><p><strong>如果不加注解，直接写方法，相当于是在子类重写定义了一个方法，这个方法并不是对父类静态方法的重写，仅仅是定义了一个和父类静态方法名字一样的子类方法。</strong></p>
</li>
<li><p><strong>原理同上： 子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说 。</strong></p>
</li>
</ol>
<h2 id="13-成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"><a href="#13-成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用" class="headerlink" title="13. 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用"></a>13. 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</h2><p>​    内部类只是 Java 编译器的概念，对于 JVM 而言，每个内部类最终都会被编译成一个独立的类，生成独立的字节码文件。<strong>内部类可以访问外部类的私有变量</strong>。 <strong>方法内部类（局部内部类）是在一个方法内定义和使用的；匿名内部类使用范围很小，他们都不能在外部使用。</strong>     <strong>成员内部类和静态内部类可以被外部使用，不过他们都可以被声明成 private，即不能被外部使用了。</strong></p>
<h3 id="1-静态内部类"><a href="#1-静态内部类" class="headerlink" title="1. 静态内部类"></a>1. 静态内部类</h3><ol>
<li><strong>内部类访问了外部类的一个私有变量 shared，其实私有变量是不能被类外部访问的，Java 的解决方法是：自动为 Outer1 生成一个非私有的方法 access$0，他返回这个私有静态变量 shared。</strong></li>
<li>使用场景：如果他与外部类关系密切，且不依赖于外部类实例，则可以考虑定义为静态内部类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> shared = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以访问外部类的私有静态变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"inner = "</span> + shared);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在类内部，可以直接使用静态内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StaticInner si = <span class="keyword">new</span> StaticInner();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outside</span> </span>&#123;</span><br><span class="line">    <span class="comment">// public 静态内部类可以被外部使用，不过要用 “外部类.静态内部类” 的方式使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer1.StaticInner osi = <span class="keyword">new</span> Outer1.StaticInner();</span><br><span class="line">        osi.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2.成员内部类"></a>2.成员内部类</h3><ol>
<li><strong>成员内部类对象总是与一个外部类对象相连的。</strong> 不能直接使用 <code>new Outer2.Inner()</code> 的方法创建对象，应该先创建一个外部类对象</li>
<li>成员内部类内部不能定义静态的变量和方法，因为成员内部类与外部是息息相关的，不应该单独使用；</li>
<li>使用场景：<strong>如果内部类与外部类关系密切，需要访问外部类的实例变量和方法，则可以考虑定义为成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回这个接口，外部类方法可能使用内部类实现这个接口，这个内部类可以被设计为 private，对外完全隐蔽。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个成员内部类对象</span></span><br><span class="line">Outer2 outer2 = <span class="keyword">new</span> Outer2();</span><br><span class="line">Outer2.Inner inner = outer2.new Inner();</span><br><span class="line">inner.innerMethod();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 成员内部类可以访问外部类的实例变量和方法</span></span><br><span class="line">            System.out.println(<span class="string">"outer a = "</span> + a);</span><br><span class="line">            <span class="comment">// 这种写法一般在重名时使用，否则 Outer.this 是多余的</span></span><br><span class="line">            Outer2.<span class="keyword">this</span>.action();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"action"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-方法内部类（局部内部类）"><a href="#3-方法内部类（局部内部类）" class="headerlink" title="3.方法内部类（局部内部类）"></a>3.方法内部类（局部内部类）</h3><ol>
<li>只能在定义的方法内使用；</li>
<li>方法内部类可以访问方法的参数和方法中的局部变量，不过，在 Java 8 之前，这些局部变量都必须被声明成 final，            Java 8 不再要求，<strong>但变量不能被重新赋值，否则会有编译错误</strong>。实际上，<strong>方法内部类操作的并不是外部的变量，而是他自己的实例变量</strong>，只是这些变量的值和外部一样，对这些变量赋值，并不会改变外部的值，为避免混淆，干脆规定必须声明为 final。</li>
<li><strong>如果的确需要修改外部的变量，那么可以将变量改为只包含该变量的数组，修改数组中的值。</strong> 例如 str 是一个只含一个元素的数组，方法内部类不能修改 str 本身，但是可以修改 str 的数组元素。</li>
</ol>
<h3 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4.匿名内部类"></a>4.匿名内部类</h3><ol>
<li><p>没有单独的类定义，在创建对象的时候定义类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> 父接口() &#123;</span><br><span class="line">    <span class="comment">// 匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只能使用一次，没有名字，没有构造方法，但可以根据参数列表调用父类的构造方法</p>
</li>
<li><p>匿名内部类能做到的，方法内部类都能做。</p>
</li>
</ol>
<h2 id="15-讲一下常见编码方式？"><a href="#15-讲一下常见编码方式？" class="headerlink" title="15. 讲一下常见编码方式？"></a>15. 讲一下常见编码方式？</h2><h3 id="1-非-Unicode-编码"><a href="#1-非-Unicode-编码" class="headerlink" title="1.非 Unicode 编码"></a>1.非 Unicode 编码</h3><blockquote>
<p>包括 ASCII（美）、ISO 8859-1、Windows-1252（西欧）、（后中国）GB2312、GBK、GB18030 和 Big5</p>
</blockquote>
<ol>
<li>ASCII<ol>
<li>128个字符的二进制表示方法，8位表示，最高位为0，剩下7位表示字符</li>
<li>数字 0 - 9，用 ‘48’ - ‘57’ 表示</li>
<li>大写字母 A - Z 用 ‘65’ - ‘90’ 表示</li>
<li>小写字母 a - z 用  ‘97’ = ‘122’ 表示（在大写的基础上加32）</li>
<li>不够表示其他国家的字符</li>
</ol>
</li>
<li>GBK<ol>
<li>建立在 GB2312 的基础上，向下兼容。GBK 增加了 14000 多个汉字，共计约 21000个汉字，包括繁体字</li>
<li>使用固定的两个字节表示，高位范围是 0X81<del>0XFE，地位字节范围是 0X40</del>0X7E 和 0X80~0XFE</li>
</ol>
</li>
</ol>
<h3 id="2-Unicode-编码"><a href="#2-Unicode-编码" class="headerlink" title="2.Unicode 编码"></a>2.Unicode 编码</h3><blockquote>
<p><strong>Unicode 给世界上所有字符都分配了一个唯一的数字编号。</strong> 编号怎么对应到二进制表示，主要由 UTF-32、UTF-16 和 UTF-8 三种方案。</p>
</blockquote>
<ol>
<li>UTF-32<ol>
<li>每个字符都用4个字节表示，不兼容 ASCII</li>
</ol>
</li>
<li>UTF-16<ol>
<li>使用变长字节表示，大多两个字节，不兼容 ASCII</li>
</ol>
</li>
<li>UTF-8<ol>
<li>使用变长字节表示，使用的字节数 1~4个，兼容 ASCII</li>
</ol>
</li>
</ol>
<h2 id="16-Java-当中的四种引用"><a href="#16-Java-当中的四种引用" class="headerlink" title="16.Java 当中的四种引用"></a>16.Java 当中的四种引用</h2><h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h3><ol>
<li>通过类似 <code>Object obj = new Object();</code> 创建的引用，称之为“强引用”。</li>
<li>特点：<ol>
<li>其指向的对象无论如何都不会被 JVM 垃圾回收器回收，即使面临 <code>OutofMemoryError</code> 的风险；</li>
</ol>
</li>
</ol>
<h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h3><ol>
<li><strong>描述一些还有用但非必须的对象。</strong> 对于软引用关联着的对象，如果新创建对象时，系统即将发生内存溢出，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，就会抛出内存溢出异常。</li>
</ol>
<h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h3><ol>
<li><strong>描述非必须的对象，强度低于软引用。</strong></li>
<li>被引用的对象只能生存到下一次垃圾回收之前。当垃圾回收器工作时，不关当前内存是否足够，都会回收掉被弱引用管理的对象。</li>
</ol>
<h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h3><ol>
<li>又称 <strong>幽灵引用</strong> 或 <strong>幻影引用</strong>。</li>
<li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过一个虚引用来获得一个对象实例。</li>
<li>设置的目的：<strong>能在这个对象被回收时收到一个系统的通知。</strong></li>
</ol>
<h2 id="17-深拷贝和浅拷贝的区别是什么？"><a href="#17-深拷贝和浅拷贝的区别是什么？" class="headerlink" title="17.深拷贝和浅拷贝的区别是什么？"></a>17.深拷贝和浅拷贝的区别是什么？</h2><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1.浅拷贝"></a>1.浅拷贝</h3><blockquote>
<p>被拷贝对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 </p>
<p><strong>直接调用super.clone实现的clone方法全部都是浅拷贝</strong> </p>
<p>8中基本类型和不可变对象属于直接拷贝值的类型。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%B5%85%E6%8B%B7%E8%B4%9D1.png" alt="浅拷贝"></p>
<ol>
<li>对引用类型的改变会相互影响，但是基本类型就不存在影响。</li>
<li><strong>如何实现浅拷贝：</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对象引用</span></span><br><span class="line">    <span class="keyword">private</span> Subject subj;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s, String sub)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">        subj = <span class="keyword">new</span> Subject(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//浅拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原始对象</span></span><br><span class="line">        Student stud = <span class="keyword">new</span> Student(<span class="string">"勒布朗"</span>, <span class="string">"詹姆斯"</span>);</span><br><span class="line">        System.out.println(<span class="string">"原始对象: "</span> + stud.getName() + <span class="string">" - "</span> + stud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝对象</span></span><br><span class="line">        Student clonedStud = (Student) stud.clone();</span><br><span class="line">        System.out.println(<span class="string">"拷贝对象: "</span> + clonedStud.getName() + <span class="string">" - "</span> + clonedStud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象是否一样：</span></span><br><span class="line">        System.out.println(<span class="string">"原始对象和拷贝对象是否一样: "</span> + (stud == clonedStud));</span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象的name属性是否一样</span></span><br><span class="line">        System.out.println(<span class="string">"原始对象和拷贝对象的name属性是否一样: "</span> + (stud.getName() == clonedStud.getName()));</span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象的subj属性是否一样</span></span><br><span class="line">        System.out.println(<span class="string">"原始对象和拷贝对象的subj属性是否一样: "</span> + (stud.getSubj() == clonedStud.getSubj()));</span><br><span class="line"></span><br><span class="line">        stud.setName(<span class="string">"布莱恩特"</span>);</span><br><span class="line">        stud.getSubj().setName(<span class="string">"科比"</span>);</span><br><span class="line">        System.out.println(<span class="string">"更新后的原始对象: "</span> + stud.getName() + <span class="string">" - "</span> + stud.getSubj().getName());</span><br><span class="line">        System.out.println(<span class="string">"更新原始对象后的克隆对象: "</span> + clonedStud.getName() + <span class="string">" - "</span> + clonedStud.getSubj().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原始对象: 勒布朗 - 詹姆斯</span><br><span class="line">拷贝对象: 勒布朗 - 詹姆斯</span><br><span class="line">原始对象和拷贝对象是否一样: <span class="keyword">false</span></span><br><span class="line">原始对象和拷贝对象的name属性是否一样: <span class="keyword">true</span></span><br><span class="line">原始对象和拷贝对象的subj属性是否一样: <span class="keyword">true</span></span><br><span class="line">更新后的原始对象: 布莱恩特 - 科比</span><br><span class="line">更新原始对象后的克隆对象: 勒布朗 - 科比</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>说明，<strong>对原始对象 stud 的 name 属性的改变没有影响拷贝对象；对原始对象 stud 的引用属性 subj 的改变影响了拷贝对象。</strong></li>
</ol>
<h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2.深拷贝"></a>2.深拷贝</h3><blockquote>
<p>被拷贝对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。 速度较慢且开销大。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" alt="深拷贝"></p>
<ol>
<li>两边变动相互不影响</li>
<li>相比于浅拷贝的改变在于，重写 clone 方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 重写clone()方法 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="comment">// 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立</span></span><br><span class="line">   Student s = <span class="keyword">new</span> Student(name, subj.getName()); </span><br><span class="line">   <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>需要先创建拷贝类的一个对象，再返回这个对象。</li>
</ol>
<h2 id="18-什么是编译期常量，有什么风险？"><a href="#18-什么是编译期常量，有什么风险？" class="headerlink" title="18.什么是编译期常量，有什么风险？"></a>18.什么是编译期常量，有什么风险？</h2><p>常量用 <code>static final</code> 修饰</p>
<ol>
<li><strong>编译期常量：程序在编译时就能确定这个常量的具体值；</strong></li>
<li>非编译期常量：程序在运行时才能确定常量的值，也称运行时常量。</li>
</ol>
<p>定义上来讲，声明为 final 类型的基本类型或者 String 类型并直接赋值（非运算）的变量就是编译期常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译期常量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">final</span> String str = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="comment">// 非编译期常量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = rand.nextInt();</span><br></pre></td></tr></table></figure>

<p>注意：由于在编译期常量在编译时就确定了值，使用编译期常量的地方在编译时会替换成对应的值即字面量。</p>
<p>我们一般将编译期常量声明为<code>public static final</code>类型（静态常量），在这种情况下，<strong>引用编译期常量不会导致类的初始化</strong> 。 本来引用 static 变量会引起类加载器加载常量所在类，并进行初始化，但由于是编译期常量，编译器在编译引用这个常量的类时，会直接将常量替换为对应值，也就无需再去加载常量所在的类了。 </p>
<p> <strong>编译期常量不依赖类，不会引起类的初始化；而运行时常量依赖类，会引起类的初始化</strong> 。</p>
<ol start="3">
<li><strong>风险</strong></li>
</ol>
<p>如果我们项目很大大，项目整个编译一次特别耗费时间，那么我们有可能会只编译代码修改的部分。而一旦我们修改了编译期常量A，但又未重新编译所有引用编译期常量A的部分（即.java文件），那么就会导致未重新编译的那部分代码继续使用编译期常量A的旧值。 </p>
<p><strong>所以，在更新依赖文件时，要确保重新编译自己的文件，避免依旧使用原有的编译期常量旧值，产生错误。</strong></p>
<h2 id="19-你对-String-对象的-intern-熟悉吗？"><a href="#19-你对-String-对象的-intern-熟悉吗？" class="headerlink" title="19.你对 String 对象的 intern() 熟悉吗？"></a>19.你对 String 对象的 intern() 熟悉吗？</h2><ol>
<li><p>首先<code>intern()</code> 是 String 类的一个本地方法。可以减少内存中相同字符串的数量，节省一些空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据该方法的注释，我们可以得到如下结论：</p>
<ol>
<li>方法返回字符串对象的规范化表示形式；</li>
<li>String 类最初有一个空的私有的字符串池；</li>
<li>当<code>intern()</code> 方法调用的时候，如果常量池中已经包含调用<code>intern()</code> 方法的字符串时，返回的是常量池中的字符串；否则，将这个调用者字符串加入常量池，并返回这个字符串的引用。也就是说，对于两个字符串 s 和 t，<code>s.intern() == t.intern()</code> 当且仅当 <code>s.equals(t) == true</code> 。</li>
</ol>
</li>
<li><p><code>new String(&quot;xxx&quot;)</code> 都是在堆上创建字符串对象。当调用<code>intern()</code> 方法时，编译器会将字符串添加到常量池中，并返回指向该常量的一个引用。</p>
<ol>
<li><p><code>new String(&quot;xxx&quot;);</code> 是在堆上创建字符串对象；<img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/intern1.png" alt></p>
</li>
<li><p>若调用 <code>Str1.intern()</code> ，编译器会将字符串 “hello” 添加到字符串常量池中，并返回指向该常量的引用。如果此后再去调用 <code>Str2.intern()</code> ，因为常量池中已经存在 “hello”，则直接返回常量池中 ‘’hello” 的引用。<strong>（JDK 1.6）</strong><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/intern2.png" alt></p>
</li>
</ol>
</li>
<li><p>通过<strong>字面量赋值创建字符串</strong>时，会先在常量池中查找是否存在相同的字符串，若存在，则将引用直接指向常量池中的字符串；如果不存在，则在常量池中生成一个字符串，再将该字符串的引用指向接收者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String Str1 = <span class="string">"hello"</span>;</span><br><span class="line">String Str2 = <span class="string">"hello"</span>;</span><br><span class="line">String Str3 = <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure>

<p>根据上面三行代码，有如下图示：</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/intern3.png" alt></p>
</li>
<li><p><strong>对于字符串的 “+” 操作，在编译阶段会直接合并成一个字符串，相当于创建了一个字面量字符串。</strong>如：<code>String S1 = &quot;Hello&quot; + &quot; World&quot;;</code> 在编译阶段会被合并成为<code>String S1 = “Hello World”;</code> 剩下的操作就和通过字面量创建字符串一样了。</p>
</li>
<li><p><strong>对于 final 字段修饰的，编译期直接进行了常量替换；</strong></p>
</li>
<li><p><strong>常量字符串和变量拼接时</strong>，会调用<code>StringBuilder.append();</code> <strong>在堆上创建新的对象</strong>；例如：<code>String S1 = str1 + &quot;world&quot;;</code> </p>
</li>
<li><p>JDK 1.7 以后，<code>intern()</code> 方法还是会去检查常量池中是否存在调用者字符串，如果存在就直接返回引用；<strong>如果不存在</strong>，<strong>与 JDK 1.6  不同的是，不再创建一个字符串的拷贝再加入常量池，而是在常量池中生成一个对应字符串的引用。</strong> 也就是说，<strong>原来在常量池中找不到就复制一个放进去，1.7 以后就是将堆上的引用复制到常量池中。</strong></p>
</li>
<li><p>举栗说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>) + <span class="keyword">new</span> String(<span class="string">" world"</span>);</span><br><span class="line">    str2.intern();</span><br><span class="line">    String str1 = <span class="string">"hello world"</span>;</span><br><span class="line">    System.out.println(str2 == str1);	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行 str2.intern(); 的时候常量池中还没有 "hello world" 字符串，所以将 "hello world" 的在堆中的引用放入常量池；当执行 String str1 = "hello world";时，常量池中已经有一个地址了，所以直接返回那个地址，也就是 str2 指向的地址。顾两个地址相同为 true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>) + <span class="keyword">new</span> String(<span class="string">" world"</span>);</span><br><span class="line">    String str1 = <span class="string">"hello world"</span>;</span><br><span class="line">    str2.intern();</span><br><span class="line">    System.out.println(str2 == str1);	<span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第2行创建的对象放在堆中，即 str2 指向堆中的地址</span></span><br><span class="line"><span class="comment">// 第3行，此时常量池中没有 "hello world"，所以在常量池中创建一个 "hello world"</span></span><br><span class="line"><span class="comment">// 第4行，此时返回一个常量池中的引用，没人接收，所以 str2 还是指向堆中的地址</span></span><br><span class="line"><span class="comment">// 如果改为如下代码，则输出 true</span></span><br><span class="line">	str2 = str2.intern(); <span class="comment">// 相当于用 str2 来接收常量池中的 "hello world" 引用。</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="20-a-a-b-和-a-b-有什么区别？"><a href="#20-a-a-b-和-a-b-有什么区别？" class="headerlink" title="20.a = a + b  和 a += b  有什么区别？"></a>20.<code>a = a + b</code>  和 <code>a += b</code>  有什么区别？</h2><h3 id="1-a-a-b"><a href="#1-a-a-b" class="headerlink" title="1. a = a + b"></a>1. <code>a = a + b</code></h3><ol>
<li>我们先看一段代码，关于 <code>a = a + b;</code> 为方便看编译器警告，直接截图：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A21.png" alt></p>
<ol start="2">
<li>原因：</li>
</ol>
<ul>
<li>a 是一个 byte 类型，而数字 4 是一个 int 类型。在 java 中进行运算时，会进行自动类型转换，将 <code>a + 4</code> 转换成 int 类型，但是变量 a 是 byte 类型，将 int 类型 <code>a + 4</code> 强制转换成 byte 会产生错误（低转高可以，高转低在强制类型转换的条件下可能出现溢出错误）。</li>
<li>如果尝试进行强制类型转换，在 byte 取值范围内可行，但是当超出范围，会出现溢出错误或者精度下降，如下</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A22.png" alt></p>
<h3 id="2-a-b"><a href="#2-a-b" class="headerlink" title="2.a +=  b"></a>2.<code>a +=  b</code></h3><ol>
<li>直接先看代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> a = <span class="number">4</span>;</span><br><span class="line">        a += <span class="number">4</span>;</span><br><span class="line">        System.out.println(a);  <span class="comment">// 输出 8，转换正常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>+=</code> 是 java 中的一个运算符，在运算过程中，首先会进行自动类型转换，所以在编译时没有报错。</li>
<li>但是！！！！！！！！！！<strong>仅仅只是在编译时不报错，超出还是会溢出或精度下降</strong>，如果出现下列情况</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> a = <span class="number">4</span>;</span><br><span class="line">        a += <span class="number">124</span>;</span><br><span class="line">        System.out.println(a);  <span class="comment">// 输出 -128，byte 溢出，得到不是我们想要的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><ol>
<li>在两个变量的数据类型一致时，<code>a = a + b</code> 和 <code>a += b</code> 没有区别；</li>
<li>当两个变量的数据类型不同时，需要考虑数据类型的自动转换问题；</li>
<li>低位转高位没问题，但是当出现需要高位转向低位时，都要考虑溢出或者精度下降的问题。</li>
<li>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</li>
</ol>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">byte</th>
<th align="center">short</th>
<th align="center">int（默认）</th>
<th align="center">long</th>
<th align="center">float</th>
<th align="center">double（默认）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">占用字节数</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
</tbody></table>
<h2 id="21-throw和throws的区别"><a href="#21-throw和throws的区别" class="headerlink" title="21.throw和throws的区别"></a>21.throw和throws的区别</h2><h3 id="1-throw"><a href="#1-throw" class="headerlink" title="1.throw"></a>1.throw</h3><ol>
<li>就是抛出异常，会触发 Java 的异常处理机制</li>
<li>return 代表正常退出，throw 代表异常退出；return 的返回值是确定的，就是上一级调用者，而 throw 后执行哪行代码经常是不确定的，由异常处理机制动态确定</li>
</ol>
<h3 id="2-throws"><a href="#2-throws" class="headerlink" title="2.throws"></a>2.throws</h3><ol>
<li>用于声明一个方法可以抛出异常，可以有多个，用逗号隔开</li>
<li>且没有对这个异常进行处理，至少没有处理完，调用者必须对其进行处理。</li>
</ol>
]]></content>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见问题-Java篇-part1</title>
    <url>/2019/11/27/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-java%E7%AF%87-part1/</url>
    <content><![CDATA[<p>最近从网上整理收集了一些面试问题以及答案，反复复习，理解。</p>
<a id="more"></a>

<h1 id="1-Java-篇"><a href="#1-Java-篇" class="headerlink" title="1. Java 篇"></a>1. Java 篇</h1><h2 id="1-Java-基础知识"><a href="#1-Java-基础知识" class="headerlink" title="1. Java 基础知识"></a>1. Java 基础知识</h2><h3 id="1-java中-和-equals-和-hashCode-的区别"><a href="#1-java中-和-equals-和-hashCode-的区别" class="headerlink" title="1.  java中 == 和 equals 和 hashCode 的区别"></a>1.  java中 == 和 equals 和 hashCode 的区别</h3><ol>
<li><p><strong>==</strong></p>
<ol>
<li>作用：比较两个操作数的关系，返回一个 boolean 值</li>
<li>具体表现：如果两个操作数是基本数据类型（8种），比较值是否相等；如果操作数是引用类型，比较的是内存地址是否相同。</li>
</ol>
</li>
<li><p><strong>equals</strong></p>
<ol>
<li>Object 类方法</li>
<li>作用：比较引用地址是否相同，在 Object 类中的实现为</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>很多类比如 String、Integer等都是重写了 equals 方法。因为 Object 类中的 equals 方法只是对两个引用是否指向同一块内存区域进行判断，但是在<strong>实际情况中，我们往往需要得到的是两个对象在逻辑上是否相等</strong>，如</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 实际上对象 s1 和对象 s2 指向的是不一样的地址空间</span></span><br><span class="line"><span class="comment">// 但是我们通常从逻辑上认为 s1 和 s2 是相等的，这种情况下就要重写 equals 方法，如下</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>底层还是通过 == 来判断引用地址是否相同</li>
</ol>
</li>
<li><p><strong>hashCode</strong></p>
<ol>
<li>Object 类的本地方法,返回一个对象的 hash 值，用于快速对对象进行区分，分组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>很多类都重写了 hashCode 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么使用 31</span></span><br><span class="line"><span class="comment">// 一方面：产生更分散的散列，即不同字符串 hash 值一般也不同</span></span><br><span class="line"><span class="comment">// 另外  ：计算效率更高，31*h 与 32 * h - h 即(h &lt;&lt; 5) - h 等价，</span></span><br><span class="line"><span class="comment">// 可以使用更高效率的移位和减法操作代替乘法操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>区别与联系</strong>！</p>
<ol>
<li>equals 底层还是使用 == 来进行引用地址的判断，== 还能用于基本类型操作数的值的判断；</li>
<li>当出现这样一种情况，需要多次比较对象的引用值是否相等，比如说在一个 Set 集合中，每次放入一个对象，都需要与之前的对象进行比较以排除重复元素，如果每次都是调用 equals 方法来进行比较，那么效率十分低下。在这种情况下，hashCode 就派上用场了。<strong>解决方式就是：</strong> 每次需要对比的时候，首先调用 hashCode() 去计算出一个 hash 值，然后根据该 hash 值来得到一个存放当前对象的地址，如果这个地址没有其他对象存在，那么直接把这个对象添加进去。如果已经有一个对象了，那么继续使用 equals 方法进行比较，如果返回 false，认为该集合中不存在这个对象，再进行一次散列，将该对象放入散列后计算出来的新地址里面，如果 equals 返回 true，则该 Set 里面已经有这个对象了，就不用再添加了。</li>
<li><strong>在每个重写了 equals 方法的类中，都要重写 hashCode 方法。</strong></li>
<li><strong>如果两个对象通过 equals 方法比较相等，那么他的 hashCode 一定相等；</strong> </li>
<li><strong>如果两个对象通过 hashCode 方法比较相等，那么他的 equals 不一定相等（hash 碰撞）；</strong> </li>
</ol>
</li>
</ol>
<h3 id="2-int-与-Integer-的区别"><a href="#2-int-与-Integer-的区别" class="headerlink" title="2. int 与 Integer 的区别"></a>2. int 与 Integer 的区别</h3><ol>
<li>int 是基本数据类型（8种），Integer 是 int 对应的包装类。这个包装类内部有一个实例变量，用于存储基本类型的值，这个类还有一些静态方法、静态变量和实例方法，以便对数据进行操作。</li>
<li>每种包装类都有一个静态方法<code>valueOf()</code>  接受基本类型，返回引用类型，也都有一个实例方法<code>xxxValue()</code> 返回对应的基本类型。</li>
<li>推荐使用静态的<code>valueOf()</code> 创建对象，new 每次都会创建一个新对象，但是除了 Float 和 Double 外的其他包装类，都会缓存包装类对象，减少需要创建对象的次数，节省空间，提升性能。</li>
<li>所有包装类的共同点<ol>
<li>重写 Object 的方法<ol>
<li>equals 和 hashCode</li>
</ol>
</li>
<li>都实现了 Comparable 接口</li>
<li>包装类和String<ol>
<li><code>int a = Integer.parseInt(&quot;1&quot;)</code> ：根据字符串返回基本类型的值</li>
<li><code>String a = Integer.toString(1)</code> ：根据基本类型值返回字符串形式</li>
</ol>
</li>
<li>常用变量<ol>
<li>Integer.MAX_VALUE</li>
<li>Double.POSITIVE_INFINITY</li>
</ol>
</li>
<li>Number<ol>
<li>这是6种数值包装类的共同父类，包装类可以返回任意的基本数值类型</li>
</ol>
</li>
<li>不可变性<ol>
<li>所有包装类都声明为 final，不能被继承</li>
<li>内部基本类型都是私有的，且声明为 final</li>
<li>没有定义 setter 方法</li>
<li>不可变使得程序变的简单安全</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-抽象类的意义"><a href="#3-抽象类的意义" class="headerlink" title="3. 抽象类的意义"></a>3. 抽象类的意义</h3><ol>
<li><p>没有具体对象对应的类，如动物类、水果类；</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;	<span class="comment">// 动物的抽象的动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>定义了抽象方法的类必须被声明为抽象类；抽象类可以没有抽象方法。</strong></p>
</li>
<li><p>抽象类和具体类一样可以定义具体方法、实例变量等，但不能使用 new 创建对象。只能用他的具体子类来创建对象。</p>
</li>
<li><p>具体子类继承抽象类后必须<strong>重写</strong>抽象类的抽象方法。</p>
</li>
<li><p><strong>抽象类的意义</strong></p>
<ol>
<li>为了继承使用；</li>
<li>引入抽象方法和抽象类，对于一些类和方法，引导使用者正确使用他们，减少误用。告诉子类一定要去实现父类的某一些方法。使用抽象类，类的使用者创建对象的时候就知道必须要使用某个具体子类，而不可能误用不完整的父类。</li>
</ol>
</li>
</ol>
<h3 id="4-接口和抽象类的区别"><a href="#4-接口和抽象类的区别" class="headerlink" title="4. 接口和抽象类的区别"></a>4. 接口和抽象类的区别</h3><ol>
<li>两者经常配合使用，<strong>接口定义能力，抽象类提供默认实现</strong>；</li>
<li>抽象类和接口都不能用于创建对象，接口中的方法其实都是抽象方法；</li>
<li>接口中不能定义实例变量，抽象类可以，一个类可以实现多个接口，但只能继承一个父类；</li>
<li>一个接口经常有一个对应的抽象类；</li>
<li><strong>实现接口，要重写接口的所有方法，除非实现类是抽象类；继承抽象父类，可以有选择的重写需要的方法；</strong></li>
<li>java 9版本中，接口的内容<ol>
<li>成员变量是常量，<code>public static final 数据类型 常量名称 = 数据值;</code></li>
<li>从 java 8 开始，接口中允许定义<strong>默认方法</strong>，引入默认方法主要是函数式数据处理的需求，是为了便于给接口增加功能，<code>public default 返回值类型 方法名(参数列表);</code></li>
<li>从 java 8 开始，接口中允许定义<strong>静态方法</strong>，<code>public static 返回值类型 方法名(参数列表){方法体};</code></li>
<li>从 java 9 开始<strong>允许定义私有方法，方便多个静态或默认方法复用代码</strong><ol>
<li>普通私有方法，<code>private 返回值类型 方法名(参数列表){方法体}；</code></li>
<li>静态私有方法，<code>private static 返回值类型 方法名(参数列表){方法体};</code></li>
</ol>
</li>
<li>接口中不能有静态代码块，也没有构造方法</li>
</ol>
</li>
</ol>
<h3 id="5-能否创建一个包含可变对象的不可变对象"><a href="#5-能否创建一个包含可变对象的不可变对象" class="headerlink" title="5. 能否创建一个包含可变对象的不可变对象?"></a>5. 能否创建一个包含可变对象的不可变对象?</h3><p>​    可以创建一个包含可变对象的不可变对象。只要确<strong>保不要共享可变对象的引用，确保该引用不会被修改</strong>，当需要改变这个可变对象时，就返回原对象的一个拷贝。</p>
<h3 id="6-谈谈对-java-多态的理解"><a href="#6-谈谈对-java-多态的理解" class="headerlink" title="6. 谈谈对 java 多态的理解"></a>6. 谈谈对 java 多态的理解</h3><ol>
<li><p>面向对象的三大基本特性：<strong>封装、继承和多态</strong>，多态也称为：动态绑定、后期绑定或运行时绑定</p>
<ol>
<li><strong>封装：</strong> 将对象的实现细节隐藏起来，然后通过公用方法来暴露该对象的功能；</li>
<li><strong>继承：</strong> 实现软件复用的基本手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法（父类 private 修饰的方法和属性除外）。</li>
<li><strong>多态：</strong> 子类对象可以直接赋值给父类变量，但<strong>运行时依然表现出子类的行为特征</strong>，意味着同一类型的对象在执行过程中可以表现出不同的行为特征。</li>
</ol>
</li>
<li><p>引用变量：</p>
<ol>
<li><strong>编译时类型：</strong> 由声明该变量时的类型决定</li>
<li><strong>运行时类型：</strong> 实际赋给该变量的对象决定</li>
<li>二者不一致，就可能出现多态</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Father f = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="comment">// 引用变量 f 的编译时类型为 Father，运行时类型为 Son</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态：<strong>编译看父类，运行看子类。</strong></p>
<ol>
<li>故<strong>引用变量只能调用声明该变量时所使用的类中的方法，因为编译不通过，也就不存在运行了。</strong></li>
<li>因为子类继承父类之后，可能扩充了自己的方法，而父类没有这些扩充的方法，所以使用<strong>父类来声明的引用变量就无法调取这些由子类扩写的方法</strong>。与方法不同，对象的实例变量不具备多态性，因此还是使用父类的实例变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father f = <span class="keyword">new</span> Son();</span><br><span class="line">        f.father(); <span class="comment">// 输出 “我是儿子，继承自Father。”</span></span><br><span class="line">        System.out.println(f.fatherSay); <span class="comment">// 输出 “我是爸爸” 而不是 “我是儿子”</span></span><br><span class="line">        <span class="comment">//f.eat(); // 编译器警告: Cant resolve method "eat()"</span></span><br><span class="line">        <span class="comment">// 如果使用类型转换</span></span><br><span class="line">        ((Son) f).eat();	<span class="comment">// 输出 “我爸没有这个方法”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String fatherSay = <span class="string">"我是爸爸"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是爸爸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器提示  Filed 'fatherSay' never used </span></span><br><span class="line">    <span class="keyword">public</span> String fatherSay = <span class="string">"我是儿子"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是儿子，继承自Father。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我爸没有这个方法。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="7-String、StringBuffer、StringBuilder-区别"><a href="#7-String、StringBuffer、StringBuilder-区别" class="headerlink" title="7. String、StringBuffer、StringBuilder 区别"></a>7. String、StringBuffer、StringBuilder 区别</h3><ol>
<li><p>都是 final 类，都不能被继承</p>
</li>
<li><p>String 不可变，StringBuffer 和 StringBuilder 可变。任何对于 String 的改变都会产生新的对象，然后将指针指向新的对象，而对于 StringBuilder 和 StringBuffer 所指向对象的改变都不会产生新的对象。</p>
</li>
<li><p><strong>StringBuilder 是线程不安全的，StringBuffer 是线程安全的，支持并发操作。单线程环境选择 StringBuilder效率更高，多线程环境选择 StringBuffer 更安全。</strong></p>
</li>
<li><p>String 类型的对象创建后会在内存中被放在一个叫做<strong>字符串常量池</strong>的共享区域。当通过常量形式使用一个字符串时，使用的就是常量池中的那个对应的 String 类型的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String hh = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>&#125;);</span><br><span class="line">String s1 = hh;</span><br><span class="line">String s2 = hh;</span><br><span class="line">System.out.println( s1 == s2 );	<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String 可以直接使用 + 和 += 运算符，java 底层编译器一般会转换成 StringBuilder，通过 append 方法实现上述操作。</p>
</li>
</ol>
<h3 id="8-泛型中-extends-和-super-的区别"><a href="#8-泛型中-extends-和-super-的区别" class="headerlink" title="8. 泛型中 extends 和 super 的区别"></a>8. 泛型中 extends 和 super 的区别</h3><ol>
<li><p>都是泛型中的通配符；</p>
</li>
<li><p>extends 指定通配符的上限（<strong>协变：只出不进</strong>）：<strong>指定通配符上限的集合，只能从集合中取元素，取出的元素总是上限的类型，不能添加</strong>，因为<strong>编译器无法确定集合元素是哪种子类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Shape&gt; list;	<span class="comment">// 表泛型形参必须是 Shape 的子类</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>super 指定通配符的下限（<strong>逆变：只进不出</strong>）：<strong>只添加元素，取出的元素当 Object 类型处理，可能要强制转换，不能取</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Bar&gt; list;	<span class="comment">// 泛型形参是 Bar 的父类</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="9-进程和线程的区别"><a href="#9-进程和线程的区别" class="headerlink" title="9. 进程和线程的区别"></a>9. 进程和线程的区别</h3><p>​    两者是不同的操作系统资源管理方式。</p>
<ol>
<li>进程：资源分配的基本单位</li>
<li>线程：程序执行的基本单位</li>
<li>协程：又称微线程，“子程序就是协程以一种特例”。<ol>
<li>执行效率高</li>
<li>不需要多线程的锁机制</li>
</ol>
</li>
<li>区别<ol>
<li>拥有资源<ol>
<li>进程拥有独立的地址空间</li>
<li>线程只是一个进程中的不同的执行路径</li>
<li>进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换； </li>
</ol>
</li>
<li>调度</li>
<li>系统开销<ol>
<li>线程执行开销小，不利于资源的管理和保护</li>
<li>进程相反</li>
<li>CPU 切换线程比切换进程开销小</li>
</ol>
</li>
<li>通信方面<ol>
<li>线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点） </li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="10-final，finally，finalize的区别"><a href="#10-final，finally，finalize的区别" class="headerlink" title="10.final，finally，finalize的区别"></a>10.final，finally，finalize的区别</h3><ol>
<li><p>final 修饰一个类或者方法，表示该类或者方法不允许扩展。修饰类代表这个类不能被继承，修饰方法代表这个方法不能被子类重写。修饰变量表示这个变量是一个常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">void</span> <span class="title">say</span>() </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>finally：用在 Java 异常体系中用于关闭资源</p>
</li>
<li><p>finalize：有些面向对象的程序设计语言，如 C++，有显示的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码，在析构器中，最常见的操作是回收分配给对象的存储空间。Java 有自动垃圾回收器，所以不支持析构器。</p>
<ol>
<li>但，当对象使用了内存之外的一些其他资源，当这个资源不再需要时，将其回收和再利用就很重要；</li>
<li>可以为任何一个类添加 <strong>finalize 方法，该方法将会在垃圾回收器清除对象之前调用</strong>，不用过分依赖。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础问题-计算机网络</title>
    <url>/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>计算机基础问题-计算机网络</p>
<a id="more"></a>

<h2 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1.计算机网络"></a>1.计算机网络</h2><h3 id="1-一台计算机是如何把数据发送给另外一台计算机的？"><a href="#1-一台计算机是如何把数据发送给另外一台计算机的？" class="headerlink" title="1. 一台计算机是如何把数据发送给另外一台计算机的？"></a>1. 一台计算机是如何把数据发送给另外一台计算机的？</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485105&idx=1&sn=c045b7599c1637776dd89890cac5a9b5&scene=21#wechat_redirect" target="_blank" rel="noopener">参考来源</a></p>
<p>基于网络通信的五层模型来回答：</p>
<ol>
<li><p><strong>物理层：</strong>物理层负责把两台计算机连起来，在计算机之间通过高低电频来传送0,1电信号</p>
</li>
<li><p><strong>数据链路层：</strong> 制定规则来进行0，1的传送，以便让计算机识别0,1电信号代表的实际含义</p>
<ul>
<li><p><strong>以太网协议：</strong>一组电信号构成的数据包称为一个帧，由表头和数据构成。表头的长度固定为18字节，数据部分长度不一定，所以一个帧的大小一般为64-1518字节，太大的就分为多个帧传输。计算机与计算机之前如何区分呢？引入下一个概念，唯一标识MAC</p>
</li>
<li><p><strong>MAC地址：</strong>每个网卡都有一个唯一的地址，称为MAC地址。由48字节构成，唯一标识</p>
</li>
<li><p><strong>广播与ARP协议：</strong></p>
<ul>
<li>ARP：Address Revolution Protocol，地址解析协议</li>
<li>广播只在同一个子网中，数据包里面含有接收者的MAC地址，收到广播消息的子网内的主机，将数据包中的MAC地址拿出来和自己的MAC对比，如果一样，说明发送方找的就是我，那么就接收这个数据包，否则丢弃。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>网络层：</strong> 如果在一个子网内，通过广播的形式传送数据，如果不在一个子网内，那么就将数据发给网关，让网关进行转发</p>
<ol>
<li><strong>IP 协议：</strong></li>
<li>0.0.0.0 ~ 255.255.255.255<ol start="2">
<li>网络部分和主机部分</li>
<li>判断两个 IP 地址是否是一个子网，还需要知道子网掩码，子网掩码主机位全是1</li>
</ol>
</li>
<li><strong>ARP 协议：</strong><ol>
<li>通过 ARP 协议能够获得其他主机的 MAC 地址</li>
<li>ARP 协议通过广播的形式向一个子网内的其他所有主机发送一个数据包，包含想要获得的MAC地址对应的IP地址。对方收到这个数据包后，将IP地址拿出来和自己的IP地址进行比较，如果相同，就把自己的IP地址回复给想要获取的那一方，否则丢弃。</li>
</ol>
</li>
<li><strong>DNS 服务器：</strong><ol>
<li>通常我们想要访问一个网站，输入的是网站的域名，而不是直接输入网站的 IP 地址。</li>
<li>DNS 服务器能够将我们访问的网站域名解析为对应的 IP 地址</li>
</ol>
</li>
<li>网络层的功能：让我们能够在网络中找到一台计算机在哪里，判断我们是否属于同一个子网。</li>
</ol>
</li>
<li><p><strong>传输层：</strong> 建立<strong>端口</strong>到<strong>端口</strong>的连接。以供特定的程序来接收处理。</p>
<ol>
<li>常见 TCP 与 UDP 协议</li>
</ol>
</li>
<li><p><strong>应用层：</strong></p>
<ol>
<li>指定数据的格式、规则，收到好才好解读渲染。</li>
</ol>
</li>
</ol>
<h3 id="2-电脑的-ip-是怎么来的？"><a href="#2-电脑的-ip-是怎么来的？" class="headerlink" title="2. 电脑的 ip 是怎么来的？"></a>2. 电脑的 ip 是怎么来的？</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485482&idx=1&sn=39550699789ae9078da3420f0e0e3b09&scene=21#wechat_redirect" target="_blank" rel="noopener">参考来源</a></p>
<ol>
<li>DHCP （Dynamic Host Configuration Protocol）动态主机配置协议</li>
<li>客户端请求 IP<ol>
<li><strong>客户端发送一个广播，广播的目的 IP 是 255.255.255.255，目的端口是 67，为了让别人知道他是来请求一个 IP 地址的，将客户端的源 IP 设置为 0.0.0.0，源端口是 68。</strong> 将这个 IP 请求报文称为 <strong>discover 报文</strong>（UDP）</li>
</ol>
</li>
<li><strong>DHCP 响应</strong><ol>
<li>DHCP 收到源 IP 为0.0.0.0 的报文，就会给他提供一个 IP，包括 <strong>IP地址，子网掩码、网关、IP有效期</strong>，通过发起请求的客户端的 MAC 地址，DHCP服务器将这些信息送过去。也是通过广播的形式，此时广播报文的源 IP 为DHCP服务器的 IP，目的IP为255.255.255.255</li>
<li>DHCP 提供 IP 的报文称为 <strong>offer 报文</strong>。</li>
</ol>
</li>
<li><strong>客户端挑选 IP 地址</strong><ol>
<li>可能不止一台 DHCP 服务器收到了 IP 请求，对于 客户端而言，一般选择最先收到的 offer 报文，然后给对应的 DHCP 服务器发送一个 request 报文，表明已经收到了他提供的 IP。</li>
</ol>
</li>
<li>如果 DHCP 服务器不在所在的局域网，那么就需要网关进行传递，中间涉及到 NAT 地址转换协议</li>
</ol>
<h3 id="3-谈谈NAT"><a href="#3-谈谈NAT" class="headerlink" title="3.谈谈NAT"></a>3.谈谈NAT</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485189&idx=1&sn=70571f1c204c7b1e9cedf10ff6885492&scene=21#wechat_redirect" target="_blank" rel="noopener">参考来源</a></p>
<ol>
<li>NAT（Network Address Translation）</li>
<li>为减少 IP 地址的消耗，可以一个公司拥有一个属于自己的内网（局域网），该局域网分配有一个 IP 地址，可以作为整个局域网的网关，与外界网络进行通信；</li>
<li>局域网内的主机想要和外部的网络进行通信，需要经过这个网关，为了识别局域外内部是哪一台主机想要和外界通信，网关维护有一个地址转换表，存储的是内部主机的 IP：端口号 与映射后的 IP：端口号 对照表；</li>
<li>通过这个地址转换表，即 NAT 协议，局域网内部的主机就能够和外界通信了</li>
<li>局域网内的 IP 称为 内网IP</li>
<li>网关 IP，百度等这样的 IP 称为 全球IP</li>
</ol>
<h3 id="4-三次握手"><a href="#4-三次握手" class="headerlink" title="4. 三次握手"></a>4. 三次握手</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485310&idx=1&sn=615cd1a1243e3b6ab3d1c0b654d29f8b&scene=21#wechat_redirect" target="_blank" rel="noopener">参考来源</a></p>
<ol>
<li><p><strong>作用：</strong></p>
<ol>
<li>确认双方的接收与发送能力是否正常</li>
<li>防止错误连接到达服务器，让 Server 错误打开连接</li>
<li>指定自己的初始化序列号，为后面的可靠传送做准备</li>
<li>如果是 HTTPS 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密秘钥的生成</li>
</ol>
</li>
<li><p><strong>三次握手的过程</strong></p>
<p>刚开始，客户端处于 closed 状态，服务器端处于 listen 状态</p>
<ol>
<li><strong>第一次握手：</strong> 客户端给服务器端发送一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_SENT 阶段</li>
<li><strong>第二次握手：</strong> 服务器端收到来自客户端的 SYN 报文之后，会以自己的 SYN 报文作为回答，并且也指定了自己的初始化序列号 ISN（s）。同时把 客户端的 ISN（c）+ 1 作为 ACK 的值，表明自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 状态</li>
<li><strong>第三次握手：</strong> 客户端收到 SYN 报文后，会发送一个 ACK 报文，当然，也是把服务器的 ISN（s）+ 1 作为 ACK 的值，表示已经收到了服务端的 SYN，此时客户端处于 ESTABLISHED 状态</li>
<li>服务器收到 ACK 报文后，也就处于 ESTABLISHED  状态，双方建立起来连接。</li>
</ol>
</li>
<li><p>示意图</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p>
<ol start="4">
<li><p>常见问题</p>
<ol>
<li><strong>ISN（Initial Sequence Number） 是固定的吗?</strong></li>
</ol>
<blockquote>
<p>通信双方交换 ISN 以便让对方知道接下来接受数据的时候如何按照序列号来重新组装数据。如果是固定的，攻击者很容易猜出后续的确认号，因此，<strong>ISN 是动态生成的</strong>。</p>
</blockquote>
<ol start="2">
<li><strong>什么是半连接队列？</strong></li>
</ol>
<blockquote>
<p>服务器端第一次收到 SYN 后，就处于 SYN_RECD 状态，此状态下的请求连接放在一个队列里面，该队列就是<strong>半连接队列</strong>。完成三次握手后，建立起来的连接会放在一个<strong>全连接队列</strong>中。如果队列满，可能出现丢包现象。</p>
</blockquote>
<ol start="3">
<li><strong>SYN-ACK 重传机制</strong></li>
</ol>
<blockquote>
<p>服务器发送完 SYN - ACK 包，如果未收到客户端的确认报文，服务器进行首次重传，等待一段时间后仍未收到确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，那么这个连接信息就从半连接队列中删除。等待时间呈指数增长：1 2 4 8.。。</p>
</blockquote>
<ol start="4">
<li><strong>三次握手过程中可以携带数据吗？</strong></li>
</ol>
<blockquote>
<p>第一二次握手不能携带，第三次握手，其实客户端已经处于 建立连接 状态了，所以第三次握手可以携带数据。</p>
<p>第一次握手不能携带数据是避免服务器收到恶意的客户端在第一次握手信息中携带大量数据，且反复重发 SYN 报文，造成服务器时间，空间的浪费。</p>
</blockquote>
<ol start="5">
<li><strong>为什么两次握手不行？</strong></li>
</ol>
<blockquote>
<p> 客户端发送的请求如果在网络中滞留，则会隔很长时间才能收到服务器发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接，但滞留的连接请求最后还是会到达服务器。如不进行第三次握手，那 Server 就打开两个连接。若有第3次握手，客户端会忽略 Server 之后发送的滞留请求的连接确认。</p>
</blockquote>
</li>
</ol>
<h3 id="5-四次挥手"><a href="#5-四次挥手" class="headerlink" title="5. 四次挥手"></a>5. 四次挥手</h3><p>刚开始，双方都处于 ESTABLISHED 状态，假如是客户端首先发起关闭请求：</p>
<ol>
<li><strong>第一次挥手：</strong> 客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端会处于 <strong>FIN_WAIT1</strong> 状态；</li>
<li><strong>第二次挥手：</strong> 服务器端收到一个 FIN 报文后，会发送 ACK 报文，且把客户端的序列号+1作为 ACK 报文的序列号值，表明已经收到客户端的 FIN 报文了，此时服务器端处于 <strong>CLOSE_WAIT</strong> 状态。</li>
<li><strong>第三次挥手：</strong> 如果服务器端也想断开连接了，一样发送一个 FIN 报文给客户端，且指定一个序列号。此时服务器端处于 <strong>LAST_ACK</strong>  状态</li>
<li><strong>第四次挥手：</strong> 客户端收到 FIN 后，发送一个 ACK 作为应答，此时客户端处于  <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务器端收到自己的 ACK 报文之后就进入 <strong>CLOSED</strong>  状态。</li>
<li>服务器端收到 ACK 报文之后，也就处于关闭状态了。</li>
<li>示意图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p>
<h4 id="1-注意要点："><a href="#1-注意要点：" class="headerlink" title="1.注意要点："></a>1.<strong>注意要点：</strong></h4><ol>
<li>每一次报文交换后，客户端与服务器端的状态是什么样的。</li>
<li>Client 发送了 FIN 报文后，Server  一收到这个报文就进入 Close-Wait 状态，这个状态是为了让 Server 发送还未发送完成的数据，传送完后，Server 也发送 FIN 来结束连接。</li>
<li><strong>Client 接收到 Server 的 FIN 后，需要进入一个 Time-Wait 状态，时间为 2MSL（最大报文存活时间），再进入 Closed 状态，原因？</strong><ol>
<li>确保最后一个确认报文能够到达，若 Server 没有收到 Client 的 ACK，就会重新发送 FIN 报文，Client 等待一段时间就是为此；</li>
<li>等待一段时间是为了让本地连接持续时间内产生的所有报文从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ol>
</li>
</ol>
<h3 id="6-TCP流量控制机制"><a href="#6-TCP流量控制机制" class="headerlink" title="6. TCP流量控制机制"></a>6. TCP流量控制机制</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485202&idx=1&sn=1e2222aa509d762a4ac0efc317163155&scene=21#wechat_redirect" target="_blank" rel="noopener">参考来源</a></p>
<ol>
<li><strong>为什么要进行流量控制？</strong></li>
</ol>
<blockquote>
<p> 接收方缓存满后，再接受数据包会<strong>出现丢包的问题</strong>，为了避免丢包问题，控制发送方发送速率,让接收方、发送方处于动态平衡的策略叫做<strong>流量控制</strong>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B61.png" alt></p>
<ol start="2">
<li><strong>如何控制</strong></li>
</ol>
<blockquote>
<p>接收方每次接收到数据后，在<strong>发送确认报文</strong>的时候可以将自己<strong>缓冲区还剩下多少空间（接收窗口 win）</strong>告诉发送方。</p>
<p>发送方收到这个接收窗口的信息后，便调整自己的发送速率，即<strong>调整发送窗口</strong>的大小，当发送窗口变为0，则停止发送数据，避免出现丢包的情况。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B62.png" alt></p>
<ol start="3">
<li><strong>发送方什么时候再继续发送数据？</strong><ol>
<li>当发送方收到 win = 0 的消息后，就停止发送报文，同时打开一个<strong>定时器</strong>，每隔一段时间就发送一个<strong>测试报文</strong>去询问接收方，“你准备好了吗？”，如果接收方回复可以继续发送，则继续发送；若 win 还是等于 0 ，则刷新启动定时器，准备下一次询问。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B63.png" alt></p>
<h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h4><ol>
<li>TCP/IP 全双工传输，因此通信双方都有两个滑动窗口，一个用于接受数据，<strong>接收窗口</strong>；一个用于发送数据，<strong>发送窗口（拥塞窗口）</strong>。指出窗口大小的通知称为 “<strong>窗口通告</strong>”。</li>
<li>接收窗口的大小固定吗？<ol>
<li>现在的TCP协议中，大小是动态调整的</li>
</ol>
</li>
<li>接收窗口越大越好吗？<ol>
<li>太小，丢包率上升；太大，消耗内存。</li>
<li>根据网络环境以及发送方的拥塞窗口来进行动态调整。</li>
</ol>
</li>
<li>一般情况下：接收窗口 &gt;= 发送窗口</li>
</ol>
<h3 id="7-拥塞控制机制"><a href="#7-拥塞控制机制" class="headerlink" title="7.  拥塞控制机制"></a>7.  拥塞控制机制</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485204&amp;idx=1&amp;sn=27daef390eec05b3d5db7cebcdcb4b7c&source=41#wechat_redirect" target="_blank" rel="noopener">参考来源</a></p>
<h4 id="1-为什么要进行拥塞控制？"><a href="#1-为什么要进行拥塞控制？" class="headerlink" title="1.为什么要进行拥塞控制？"></a>1.为什么要进行拥塞控制？</h4><p>​    假设主机A和主机B通信</p>
<p>​    当主机A给主机B发送报文后，由于某些原因，迟迟没有收到主机B的ACK确认报文，那么主机A会认为报文被丢失了，那么主机A将继续给主机B发送报文。但是现实情况可能是因为网络中有太多主机占用信道资源，导致<strong>网络拥塞</strong>，主机A第一次给主机B发送的报文还是可以到达主机B的，但是A再次给主机B发送了一个报文，不仅造成网络进一步拥塞，还浪费了信道资源。所以我们需要进行拥塞控制。</p>
<h4 id="2-如何知道网络的拥塞情况？"><a href="#2-如何知道网络的拥塞情况？" class="headerlink" title="2.如何知道网络的拥塞情况？"></a>2.如何知道网络的拥塞情况？</h4><p>​    将A一次性连续发送的数据包个数称之为“<strong>拥塞窗口</strong>”，用N表示吧。那么A怎么知道网络的拥塞情况呢？</p>
<p>开始阶段，发送数据包试探，其中 N 指数增长，到达一个阈值 ssthresh 后，再线性增长。</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B61.png" alt></p>
<h4 id="3-到了瓶颈值后怎么办？"><a href="#3-到了瓶颈值后怎么办？" class="headerlink" title="3.到了瓶颈值后怎么办？"></a>3.到了瓶颈值后怎么办？</h4><ol>
<li>将达到瓶颈值的 N 称为 Max；</li>
<li>到达 Max 后，我们就回到最原始的状态，1 2 4 8 。。。这样开始，<strong>同时，</strong> 设置阈值 <strong>ssthresh​ = Max / 2</strong></li>
</ol>
<h4 id="4-超时事件一定是网络拥塞吗？"><a href="#4-超时事件一定是网络拥塞吗？" class="headerlink" title="4.超时事件一定是网络拥塞吗？"></a>4.超时事件一定是网络拥塞吗？</h4><p>​    还有可能是某个数据包出现了丢失或者损害，导致这个数据包超时时间发生。</p>
<p>通过冗余 ACK 防止这种情况。当 A 连续收到三个确认 M2 的 ACK  且M3超时事件还没发生。A就知道 M3 可能丢失了，这个时候A就不必等待 M3 设置的计时器到期了，而是<strong>快速重传</strong>M3 。 并且把 ssthresh 设置为 Max 的一半，即 ssthresh = Max / 2 , <strong>但是这个时候并非把控制窗口 N 设置为1，而是让N = ssthresh，N 在一个一个增长。</strong> 这种情况也叫做 <strong>快速恢复。</strong></p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B62.png" alt></p>
<h3 id="8-在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"><a href="#8-在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？" class="headerlink" title="8.在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"></a>8.在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485074&idx=1&sn=f4e44c4b675adc6e13b4704839c5a19d&scene=21#wechat_redirect" target="_blank" rel="noopener">参考来源</a></p>
<h4 id="1-格式验证与协议选择"><a href="#1-格式验证与协议选择" class="headerlink" title="1.格式验证与协议选择"></a>1.格式验证与协议选择</h4><ol>
<li>浏览器对用户输入的<strong>网址做初步的格式化检查</strong>，只有通过格式化检查，才会进入下一步</li>
<li>浏览器使用 http 还是 https 访问服务器？<ol>
<li>没有明确告知浏览器用哪个协议，浏览器采用默认的 http 协议</li>
</ol>
</li>
</ol>
<h4 id="2-DNS-查询"><a href="#2-DNS-查询" class="headerlink" title="2.DNS 查询"></a>2.DNS 查询</h4><ol>
<li>拥有想要访问的网站的域名还是不够的，TCP/IP 协议传送消息需要知道对方的 IP 地址</li>
<li>于是，浏览器使用 DNS（域名系统）查询域名对应的 IP 地址</li>
<li>DNS 先查询自己内存里面的 DNS Cache，没有  -》接着再看本地硬盘里面的 host 文件，还是没有</li>
<li>于是，DNS 请求 DNS 服务器，请求过程使用 UDP 协议，请求报文中还携带有网关的 MAC 地址，通过 ARP（地址解析协议）获取；</li>
<li>请求报文到达 DNS 服务器后，DNS 服务器先看自己的缓存里面有没有请求的域名对应的 IP 地址，如果有就返回，否则，DNS 服务器跑去请求 DNS 根服务器 “.”。“.” 就是根服务器，全球一共13台根域名服务器，每一台 DNS 服务器都知道这13台根服务器的 IP 地址</li>
<li>根服务器收到 “zhihu.com.”（请求的域名），知道是自己的孙子服务器，但不知道他的 IP，但知道“com” 的 IP 地址，于是 DNS 服务器就去找这个 “com”，从他那里获取到了 “zhihu.com.” 的 IP 地址，马上将这个 IP 地址转达给等待的浏览器。</li>
</ol>
<h4 id="3-三次握手"><a href="#3-三次握手" class="headerlink" title="3.三次握手"></a>3.三次握手</h4><p>​    使用 TCP 协议。</p>
<ol>
<li>三次握手成功后，建立了可靠的虚拟通道。浏览器准备将 http 请求消息发给刚刚获取到的 IP 地址（zhihu.com 域名），此时获取到一个重定向的消息，因为 zhihu.com 使用 https 协议，所以重新去请求；</li>
<li>大体和 http 请求类似。但是不同的是 <strong>https 协议是加密的、安全的、需要经过证书验证等步骤，默认端口 443</strong>。</li>
<li>经过一系列加密、解密，证书验证的操作，浏览器发起的请求终于得到了回应，https 将 zhihu.com  主页返回并最终到达了浏览器。</li>
</ol>
]]></content>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-InnoDB</title>
    <url>/2019/11/06/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>MySQL技术内幕-InnoDB存储引擎读书笔记</p>
<a id="more"></a>

<h2 id="第1章-MySQL体系结构和存储引擎"><a href="#第1章-MySQL体系结构和存储引擎" class="headerlink" title="第1章 MySQL体系结构和存储引擎"></a>第1章 MySQL体系结构和存储引擎</h2><h3 id="1-1-定义数据库和实例"><a href="#1-1-定义数据库和实例" class="headerlink" title="1.1 定义数据库和实例"></a>1.1 定义数据库和实例</h3><ol>
<li>数据库：物理操作系统文件或其他形式文件类型的集合；</li>
<li>实例：MySQL数据库由后台线程以及一个共享内存区组成；<strong>在系统上的表现就是一个进程。</strong></li>
</ol>
<h3 id="1-2-MySQL体系结构"><a href="#1-2-MySQL体系结构" class="headerlink" title="1.2 MySQL体系结构"></a>1.2 MySQL体系结构</h3><ol>
<li>数据库是由一个个文件组成，要对这些文件执行增删查改等数据库操作是不能通过简单的操作文件来更改数据库的内容，需要通过<strong>数据库实例</strong>来完成对数据库的操作。</li>
<li>存储引擎是基于表的，而不是数据库。</li>
</ol>
<h3 id="1-3-MySQL存储引擎"><a href="#1-3-MySQL存储引擎" class="headerlink" title="1.3 MySQL存储引擎"></a>1.3 MySQL存储引擎</h3><ol>
<li>MySQL数据库的核心在于存储引擎；</li>
<li>InnoBD<ol>
<li>支持事务、行锁设计、支持外检、非锁定读；</li>
<li>只要面向在线事务处理（OLTP）</li>
<li>后续详细介绍</li>
</ol>
</li>
<li>MyISAM<ol>
<li>不支持事务、表锁设计</li>
<li>支持全文索引，只要面向 OLAP 数据库应用</li>
<li>缓冲池只缓冲索引文件，而不缓冲数据文件，数据文件的缓冲交给操作系统完成</li>
</ol>
</li>
<li>NDB<ol>
<li>集群存储引擎</li>
<li>数据全放在内存中（MySQL5.1 开始非索引数据放磁盘），因此主键查找极快</li>
<li>添加NDB数据存储节点可以线性提高数据库性能，是高可用、高性能的集群系统</li>
</ol>
</li>
<li>Memory<ol>
<li>将表中数据存放在内存中</li>
<li>适用于存储临时数据的临时表</li>
<li>默认使用哈希索引，而非 B+ 索引</li>
<li>只支持表锁，并发性能差，不支持 TEXT和BLOB列类型</li>
<li>浪费内存</li>
</ol>
</li>
<li>Archive<ol>
<li>只支持 INSERT 和 SELECT</li>
<li>设计目标：提供高速的插入和压缩功能</li>
</ol>
</li>
<li>Federated<ol>
<li>只支持 MySQL 数据库表，不支持异构数据库表</li>
</ol>
</li>
<li>Maria<ol>
<li>设计目标：用来取代 MyISAM 从而成为 MySQL 的默认存储引擎。</li>
<li>支持缓存数据和索引文件，应用了行锁设计，提供 MVCC 功能，支持事务和非事务安全的选项，以及更好的 BLOB 字符类型的处理性能</li>
</ol>
</li>
<li>问题？</li>
</ol>
<ul>
<li>为什么 MySQL 不支持全文索引？<ul>
<li>答：支持，MyISAM、InnoDB都支持</li>
</ul>
</li>
<li>MySQL 数据库快是因为不支持事务？<ul>
<li>答：MyISAM 不支持，但是 InnoDB 支持。“快”是相对于不同应用来说的，对于 ETL 这种操作，MyISAM 更有优势，但在 OLTP 环境中，InnoDB 效率更高；</li>
</ul>
</li>
</ul>
<h3 id="1-4-连接-MySQL"><a href="#1-4-连接-MySQL" class="headerlink" title="1.4 连接 MySQL"></a>1.4 连接 MySQL</h3><ol>
<li>连接 MySQL操作是一个连接进程和 <strong>MySQL 数据库实例</strong>进行通信；</li>
<li>从程序设计的角度来看，本质上是<strong>进程通信</strong>。</li>
</ol>
<hr>
<h2 id="第2章-InnoDB存储引擎"><a href="#第2章-InnoDB存储引擎" class="headerlink" title="第2章 InnoDB存储引擎"></a>第2章 InnoDB存储引擎</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ol>
<li>第一个完整支持 ACID 事务的 MySQL 存储引擎</li>
<li>特点：行锁设计、MVCC、支持外键，提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和 CPU。</li>
</ol>
<h3 id="2-3-InnoDB-体系架构"><a href="#2-3-InnoDB-体系架构" class="headerlink" title="2.3 InnoDB 体系架构"></a>2.3 InnoDB 体系架构</h3><p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%841.png" alt></p>
<ol>
<li>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据；</li>
<li>此外，将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下 InnoDB 能恢复到正常运行状态。</li>
</ol>
<h4 id="2-3-1-后台线程"><a href="#2-3-1-后台线程" class="headerlink" title="2.3.1 后台线程"></a>2.3.1 后台线程</h4><p>InnoDB 是多线程模型，顾后台有多个不同的后台线程；</p>
<ol>
<li>Master Thread</li>
</ol>
<p>非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，<strong>保证数据一致性</strong>。包括脏页的刷新、合并插入缓冲。UNDO 页的回收。</p>
<ol start="2">
<li>IO Thread</li>
</ol>
<p>在 InnoDB 存储引擎中大量使用 AIO（Async IO）来处理写 IO 请求，这样可以极大提高数据库的性能。该线程主要负责这些 IO 请求的回调处理。</p>
<ol start="3">
<li>Purge Thread</li>
</ol>
<p>事务被提交后，其所使用的 undolog 可能不再需要，因此需要该线程来回收已经使用并分配的 undo 页。从 InnoDB 1.2 开始，支持多个 Purge Thread，为了进一步加快 undo 页的回收，由于该线程需要离散读取 undo 页，这样也能更进一步利用磁盘的随机读取性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'innodb_purge_threads'</span>;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| innodb_purge_threads | <span class="number">4</span>     |</span><br><span class="line">+----------------------+-------+</span><br><span class="line"><span class="number">1</span> row in set, <span class="number">1</span> warning (<span class="number">0.21</span> sec)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Page Cleaner Thread</li>
</ol>
<p>在 InnoDB 1.2.x 版本引入。作用是<strong>将之前版本中脏页的刷新操作都放到单独的线程中完成</strong>。目的是为了<strong>减轻原 Master Thread 的工作及对于用户查询线程的阻塞</strong>，进一步提高 InnoDB 存储引擎的性能。</p>
<h4 id="2-3-2-内存"><a href="#2-3-2-内存" class="headerlink" title="2.3.2 内存"></a>2.3.2 内存</h4><ol>
<li>缓冲池</li>
</ol>
<p>InnoDB 基于磁盘存储，可看做基于磁盘的数据库系统。由于 CPU 与磁盘之间速度的鸿沟，基于磁盘的数据库系统通常采用缓冲池技术来提高数据库的整体性能。</p>
<p>缓冲池简单来说是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。</p>
<p>对于数据库中页的修改操作，首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/InnoDB%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A11.png" alt="InnoDB内存数据对象"></p>
<ol start="2">
<li>LRU List、Free List 和 Flush List</li>
</ol>
<p>数据库中的缓冲池是通过 <strong>LRU（Least Recently Used 最近最少使用算法）</strong>进行管理。即最频繁使用的页在 LRU 列表的前端，最少使用的在尾端。当缓冲池不能存放新读取到的页时，首先释放 LRU 列表尾部的页。</p>
<p>InnoDB 对 LRU 进行改进，引入 midpoint 位置，将新读取到的页放入这个位置，该位置之前为 new 列表，之后为 old 列表。还引入 innodb_old_blocks_time 用于表示页读取到 mid 位置后需要等待多久时间才会被加入到 LRU 的热端，可以避免 LRU 列表中的热点数据被刷出。</p>
<ol start="3">
<li>重做日志缓冲</li>
</ol>
<p>重做日志缓冲刷新到外部磁盘的重做日志文件</p>
<ul>
<li>Master Thread 每一秒将缓冲刷新到日志；</li>
<li>每个事务提交时会将缓冲刷新到日志；</li>
<li>当重做日志缓冲池（8M）剩余空间小于 1/2 时，缓冲刷新到日志。</li>
</ul>
<ol start="4">
<li>额外的内存池</li>
</ol>
<h3 id="2-4-CheckPoint-技术"><a href="#2-4-CheckPoint-技术" class="headerlink" title="2.4 CheckPoint 技术"></a>2.4 CheckPoint 技术</h3><p>解决如下几个问题</p>
<ol>
<li>缩短数据库的恢复时间；</li>
<li>缓冲池不够用时，将脏页刷新到磁盘；</li>
<li>重做日志不可用时，刷新脏页。</li>
</ol>
<p>在 InnoDB 引擎内部，有两种 CheckPoint，分别是：</p>
<ol>
<li>Sharp CheckPoint：默认的，在数据库关闭时将所有的脏页都刷新回磁盘</li>
<li>Fuzzy CheckPoint：只刷新一部分脏页，而不是所有脏页</li>
</ol>
<h3 id="2-5-Master-Thread-工作方式"><a href="#2-5-Master-Thread-工作方式" class="headerlink" title="2.5 Master Thread 工作方式"></a>2.5 Master Thread 工作方式</h3><h3 id="2-6-InnoDB-关键特性"><a href="#2-6-InnoDB-关键特性" class="headerlink" title="2.6 InnoDB 关键特性"></a>2.6 InnoDB 关键特性</h3><h4 id="2-6-1-插入缓冲"><a href="#2-6-1-插入缓冲" class="headerlink" title="2.6.1 插入缓冲"></a>2.6.1 插入缓冲</h4><h5 id="1-Insert-Buffer"><a href="#1-Insert-Buffer" class="headerlink" title="1. Insert Buffer"></a>1. Insert Buffer</h5><p>非缓冲池一部分，而是和数据页一样，是物理页的一个组成部分。</p>
<p>满足：索引是辅助索引、索引不唯一。</p>
<h5 id="2-Change-Buffer"><a href="#2-Change-Buffer" class="headerlink" title="2. Change Buffer"></a>2. Change Buffer</h5><p>适用对象是非唯一的辅助索引。</p>
<h5 id="3-Merge-Insert-Buffer"><a href="#3-Merge-Insert-Buffer" class="headerlink" title="3. Merge Insert Buffer"></a>3. Merge Insert Buffer</h5><h4 id="2-6-2-两次写"><a href="#2-6-2-两次写" class="headerlink" title="2.6.2 两次写"></a>2.6.2 两次写</h4><p>如果说 Insert Buffer 带给 InnoDB 存储引擎的是性能上的提升，那么 doublewrite 带给他的就是数据页的可靠性。</p>
<p>有些文件系统本身就提供了部分写失效的防范机制，如 ZFS 文件系统，那么用户就不用启动 doublewrite 了。</p>
<h4 id="2-6-3-自适应哈希索引"><a href="#2-6-3-自适应哈希索引" class="headerlink" title="2.6.3 自适应哈希索引"></a>2.6.3 自适应哈希索引</h4><p>InnoDB 存储引擎会监控对表上各索引页的查询，如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index-AHI）。</p>
<p>AHI 是通过缓冲池的 B+ 树页构造而来，建立的速度快，不需要对整张表构建哈希索引。InnoDB 会自动根据访问的频率和模式来自动为某些热点页建立哈希索引。</p>
<h4 id="2-6-4-异步-IO"><a href="#2-6-4-异步-IO" class="headerlink" title="2.6.4 异步 IO"></a>2.6.4 异步 IO</h4><p>异步 IO（Asynchronous IO-AIO）方式处理磁盘操作能提高磁盘操作性能。</p>
<h4 id="2-6-5-刷新邻接页"><a href="#2-6-5-刷新邻接页" class="headerlink" title="2.6.5 刷新邻接页"></a>2.6.5 刷新邻接页</h4><hr>
<h2 id="第4章-表"><a href="#第4章-表" class="headerlink" title="第4章 表"></a>第4章 表</h2><p>表是关于特定实体的数据集合。</p>
<h3 id="4-1-索引组织表"><a href="#4-1-索引组织表" class="headerlink" title="4.1 索引组织表"></a>4.1 索引组织表</h3><p>在 InnoDB 中，表都是<strong>根据主键顺序组织存放</strong>的，这种存储方式的表称为索引组织表。在 InnoDB 中，每张表都有一个主键，如果在创建表时没有显示地定义主键，则 InnoDB 会按如下方式选择或创建主键：</p>
<ul>
<li>首先判断表中是否有非空的唯一索引（Unique NOT NULL），如果有，则列为主键；</li>
<li>如不符合上述条件，InnoDB 会自动创建一个6字节大小的指针。</li>
</ul>
<p>当表中有多个非空唯一索引时，InnoDB 会选择创建表时<strong>第一个定义的非空唯一索引</strong>为主键。主键的选择根据的是<strong>定义索引</strong>的顺序，而不是建表时列的顺序。</p>
<h3 id="4-2-InnoDB-逻辑存储结构"><a href="#4-2-InnoDB-逻辑存储结构" class="headerlink" title="4.2 InnoDB 逻辑存储结构"></a>4.2 InnoDB 逻辑存储结构</h3><p>所有数据都被逻辑地放在一个空间中，称之为<strong>“表空间（tablespace）”</strong>。表空间又由<strong>段（segment）、区（extent）、页（page）</strong>组成。页也可以称为块。</p>
<p>逻辑存储结构如下所示：</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="InnoDB逻辑存储结构"></p>
<h4 id="4-2-1-表空间"><a href="#4-2-1-表空间" class="headerlink" title="4.2.1 表空间"></a>4.2.1 表空间</h4><p>在默认情况下 InnoDB 有一个共享表空间 ibdata1，即所有数据都存放在这个表空间内。</p>
<h4 id="4-2-2-段"><a href="#4-2-2-段" class="headerlink" title="4.2.2 段"></a>4.2.2 段</h4><p>表空间由各个段组成，常见的有：<strong>数据段、索引段、回滚段</strong>。</p>
<p>因为 InnoDB 存储引擎表是<strong>索引组织</strong>的，因此数据即索引，索引即数据。</p>
<p><strong>数据段即为 B+ 树的叶子节点（图4-1 Leaf Node segment），索引段即为 B+ 树的非叶子节点</strong>（图4-1 Non-Leaf Node segment）。</p>
<h4 id="4-2-3-区"><a href="#4-2-3-区" class="headerlink" title="4.2.3 区"></a>4.2.3 区</h4><p><strong>区是连续页组成的空间，任何情况下，每个区的大小都是 1M。</strong></p>
<p>默认情况下，<strong>InnoDB 页的大小为 16KB</strong>，即一个区中有64个连续的页。从 InnoDB 1.0.x 开始引入<strong>压缩页</strong>，页大小可以由参数设置，因此区的数量跟着变化，但是区的总大小始终为 <strong>1M</strong>。</p>
<h4 id="4-2-4-页（块）"><a href="#4-2-4-页（块）" class="headerlink" title="4.2.4 页（块）"></a>4.2.4 页（块）</h4><p><strong>页是 InnoDB 磁盘管理的最小单位。</strong>常见的页类型有：</p>
<ol>
<li>数据页</li>
<li>undo 页</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲列表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩的二进制大对象页</li>
</ol>
<h4 id="4-2-5-行"><a href="#4-2-5-行" class="headerlink" title="4.2.5 行"></a>4.2.5 行</h4><p>InnoDB 是面向行（row-oriented）的，也就是数据是按行进行存放的。一页存放的行记录最多为 16 KB / 2 - 200 = 7992 行。</p>
<h3 id="4-3-InnoDB-行记录格式"><a href="#4-3-InnoDB-行记录格式" class="headerlink" title="4.3 InnoDB 行记录格式"></a>4.3 InnoDB 行记录格式</h3><p>页中保存着表中一行行的数据，数据库实例的作用之一就是读取页中存放的行记录。InnoDB 提供了两种格式来存放行记录数据。Compact（默认的）和 Redundant</p>
<h4 id="4-3-1-Compact-行记录格式"><a href="#4-3-1-Compact-行记录格式" class="headerlink" title="4.3.1 Compact 行记录格式"></a>4.3.1 Compact 行记录格式</h4><p>不管是 CHAR 类型还是 VARCHAR 类型，在 compact 格式下NULL 值都不占用任何存储空间。</p>
<h4 id="4-3-2-Redundant-行记录格式"><a href="#4-3-2-Redundant-行记录格式" class="headerlink" title="4.3.2 Redundant 行记录格式"></a>4.3.2 Redundant 行记录格式</h4><p>在 redundant 中，VARCHAR 类型的NULL值不占空间，但是 CHAR 类型 NULL 值要占空间。</p>
<h4 id="4-3-3-行溢出数据"><a href="#4-3-3-行溢出数据" class="headerlink" title="4.3.3 行溢出数据"></a>4.3.3 行溢出数据</h4><p>实测，InnoDB 存储引擎能存放 VARCHAR 类型的最大长度为65532字节，而非65535. 一般情况下，InnoDB 存储引擎的数据是存放在页类型为 B-tree node 中。但是当发生行溢出时，数据存放在页类型为 UNcompress BLOB 页中。</p>
<h4 id="4-3-4-Compressed-和-Dynamic-行记录格式"><a href="#4-3-4-Compressed-和-Dynamic-行记录格式" class="headerlink" title="4.3.4 Compressed 和 Dynamic 行记录格式"></a>4.3.4 Compressed 和 Dynamic 行记录格式</h4><p>InnoDB 1.0.x 版本引入了新的文件格式（新的页格式）。以前的 Compact 和 Redundant 格式称为 Antelope 文件格式，新的文件格式称为 Barracuda 文件格式。包括，Compressed 和 Dynamic 两种行记录格式。</p>
<p>Compressed ，存储在其中的行数据以 zlib 算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 等大长度类型的数据能够进行非常有效的存储。</p>
<h4 id="4-3-5-CHAR-的行结构存储"><a href="#4-3-5-CHAR-的行结构存储" class="headerlink" title="4.3.5 CHAR 的行结构存储"></a>4.3.5 CHAR 的行结构存储</h4><p>在多字节字符集的情况下， CHAR 和 VARCHAR 的实际行存储基本是没有区别的。</p>
<h3 id="4-4-InnoDB-数据页结构"><a href="#4-4-InnoDB-数据页结构" class="headerlink" title="4.4 InnoDB 数据页结构"></a>4.4 InnoDB 数据页结构</h3><p><strong>页是 InnoDB 存储引擎管理数据库的最小单位</strong>。页类型为 B-tree node 的页存放的即是表中行的实际数据。</p>
<p>InnoDB 数据页由以下7个部分组成：</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.png" alt="数据页结构"></p>
<h4 id="4-4-1-File-Header"><a href="#4-4-1-File-Header" class="headerlink" title="4.4.1 File Header"></a>4.4.1 File Header</h4><p>记录页的一些头信息，共占用38字节</p>
<h4 id="4-4-2-Page-Header"><a href="#4-4-2-Page-Header" class="headerlink" title="4.4.2 Page Header"></a>4.4.2 Page Header</h4><p>记录数据页的状态信息，由14个部分组成，占用56字节。</p>
<h4 id="4-4-3-Infimum-和-Supremum-Record"><a href="#4-4-3-Infimum-和-Supremum-Record" class="headerlink" title="4.4.3 Infimum 和 Supremum Record"></a>4.4.3 Infimum 和 Supremum Record</h4><p>InnoDB的每个数据页中有两个虚拟的行记录，用于限定记录的边界。这两个值在页创建时被建立，在任何情况下都不会被删除。</p>
<h4 id="4-4-4-User-Record-和-Free-Space"><a href="#4-4-4-User-Record-和-Free-Space" class="headerlink" title="4.4.4 User Record 和 Free Space"></a>4.4.4 User Record 和 Free Space</h4><h4 id="4-4-5-Page-Directory"><a href="#4-4-5-Page-Directory" class="headerlink" title="4.4.5 Page Directory"></a>4.4.5 Page Directory</h4><h4 id="4-4-6-File-Trailer"><a href="#4-4-6-File-Trailer" class="headerlink" title="4.4.6 File Trailer"></a>4.4.6 File Trailer</h4><p>检测页是否被完整地写入磁盘。占用8字节。</p>
<h3 id="4-6-约束"><a href="#4-6-约束" class="headerlink" title="4.6 约束"></a>4.6 约束</h3><h4 id="4-6-1-数据完整性"><a href="#4-6-1-数据完整性" class="headerlink" title="4.6.1 数据完整性"></a>4.6.1 数据完整性</h4><p>几乎所有的关系型数据库都提供了约束（constraint）机制，该机制确保了数据库中数据的完整性。</p>
<p>数据完整性有以下三种形式：</p>
<ol>
<li><strong>实体完整性保证表中有一个主键</strong>。可通过 Primary Key 和 Unique Key 约束来保证，也可编写一个触发器来保证数据完整性。</li>
<li><strong>域完整性保证数据每列的值满足特定的条件</strong>。可通过以下几种途径来保证：<ol>
<li>选择合适的数据类型确保一个数据值满足特定条件；</li>
<li>外键约束；</li>
<li>编写触发器；</li>
<li>考虑用 DEFAULT 约束作为强制域完整性的一个方面。</li>
</ol>
</li>
<li><strong>参照完整性保证两张表之间的关系</strong>。定义外键以强制参照完整性。</li>
</ol>
<p>对 InnoDB 本身而言，提供一下几种约束：</p>
<ul>
<li>primary key</li>
<li>unique key</li>
<li>foreign key</li>
<li>not null</li>
<li>default</li>
</ul>
<h4 id="4-6-2-约束的创建和查找"><a href="#4-6-2-约束的创建和查找" class="headerlink" title="4.6.2 约束的创建和查找"></a>4.6.2 约束的创建和查找</h4><p>创建的两种方式：</p>
<ul>
<li>表建立时就进行约束定义</li>
<li>利用 ALTER TABLE 命令来进行创建约束</li>
</ul>
<p>对于主键约束而言，其默认约束名为 PRIMARY；对于 Unique Key 约束，默认约束名和列名一样，也可以人为指定。</p>
<p>通过 information_schema 结构下的 TABLE_CONSTRAINTS 来查看当前 MySQL 库下所有的约束信息。对于外键约束的命名，可通过查看表 REFERENCE_CONSTRAINTS 来详细了解。</p>
<h4 id="4-6-3-约束和索引的区别"><a href="#4-6-3-约束和索引的区别" class="headerlink" title="4.6.3 约束和索引的区别"></a>4.6.3 约束和索引的区别</h4><p>确实，当用户创建了一个唯一索引就创建了一个唯一的约束。但约束是一个逻辑的概念，用来保证数据完整性；索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。</p>
<h4 id="4-6-4-对错误数据的约束"><a href="#4-6-4-对错误数据的约束" class="headerlink" title="4.6.4 对错误数据的约束"></a>4.6.4 对错误数据的约束</h4><p>数据库本身没有对数据的正确性进行约束。如果用户想通过约束对于数据库非法数据的插入或更新，即数据库提供报错而不是警告，那就必须设置参数 sql_mode，用来严格审核输入的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET sql_mode = &apos;STRICT_TRANS_TABLES&apos;;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-5-ENUM-和-SET-约束"><a href="#4-6-5-ENUM-和-SET-约束" class="headerlink" title="4.6.5 ENUM 和 SET 约束"></a>4.6.5 ENUM 和 SET 约束</h4><p>搭配 sql_mode 可以规定某一个域为 ENUM 指定的范围值。</p>
<h4 id="4-6-6-触发器与约束"><a href="#4-6-6-触发器与约束" class="headerlink" title="4.6.6 触发器与约束"></a>4.6.6 触发器与约束</h4><h4 id="4-6-7-外键约束"><a href="#4-6-7-外键约束" class="headerlink" title="4.6.7 外键约束"></a>4.6.7 外键约束</h4><p>外键用来保证参照完整性。MyISAM 中的外键只是起到一个注释的作用，InnoDB 完整支持外键约束。</p>
<p>用户可以在执行 CREATE TABLE 时就添加外键，也可以在表创建后通过 ALTER TABLE 命令来添加。</p>
<p>一般来说，称被引用的表为父表，引用的表称为子表。外键定义时的 ON DELETE 和 ON UPDATE 表示对父表进行 DELETE 和 UPDATE 操作时，对子表所做的操作。</p>
<p>可定义的子表操作有：</p>
<ul>
<li><strong>CASCADE：</strong>当父表发生 DELETE 和 UPDATE 操作时，对应的子表中的数据也进行 DELETE 和 UPDATE 操作；</li>
<li><strong>SET NULL：</strong>当父表发生 DELETE 和 UPDATE 操作时，相应的子表的数据被更新为 NULL，前提是子表中的列允许为 NULL。</li>
<li><strong>NO ACTION：</strong>当父表发生 DELETE 和 UPDATE 操作时，抛出错误，不允许这类操作发生。</li>
<li><strong>RESTRICT：</strong>当父表发生 DELETE 和 UPDATE 操作时，抛出错误，不允许这类操作发生。如果定义外键时没有指定 ON DELETE 或 ON UPDATE ，RESTRICT 就是默认的外键设置。</li>
<li>指定RESTRICT（或者NO ACTION）和忽略ON DELETE或者ON UPDATE选项的效果是一样的。</li>
</ul>
<p>外键约束对于参照完整性约束能起到很好的作用，但是对于数据的导入操作，外键约束的检查会浪费大量时间，因为 MySQL 的外键是即时检查的，所以对导入的每一行都会进行外键检查，用户可以在导入过程中忽视外键的检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET foreign_key_checks = 0;</span><br><span class="line">mysql&gt; LOAD DATA...</span><br><span class="line">mysql&gt; Set foreign_key_checks = 1;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第5章-索引与算法"><a href="#第5章-索引与算法" class="headerlink" title="第5章 索引与算法"></a>第5章 索引与算法</h2><h3 id="5-1-InnoDB-存储引擎索引概述"><a href="#5-1-InnoDB-存储引擎索引概述" class="headerlink" title="5.1 InnoDB 存储引擎索引概述"></a>5.1 InnoDB 存储引擎索引概述</h3><p>几种常见的索引：</p>
<ul>
<li><strong>B+ 树索引：</strong>目前关系型数据库系统中查找最为常用和最为有效的索引。B+ 树的构造类似于二叉树，根据键值快速找到数据。</li>
<li>全文索引</li>
<li>哈希索引：自适应的，会根据表的使用情况自动为表生成哈希索引，不能认为干预。</li>
</ul>
<p>B+ 树索引<strong>并不能找到一个给定键值的具体行</strong>。他<strong>只能找到数据行所在的页</strong>，然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h3 id="5-2-数据结构与算法"><a href="#5-2-数据结构与算法" class="headerlink" title="5.2 数据结构与算法"></a>5.2 数据结构与算法</h3><h4 id="5-2-1-二分查找"><a href="#5-2-1-二分查找" class="headerlink" title="5.2.1 二分查找"></a>5.2.1 二分查找</h4><p>每页 Page Directory 中的槽是按照主键顺序存放的，对于某一条具体记录的查询时通过对 Page Directory 进行二分查找得到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">计算中间索引，避免整型溢出</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-二分查找树（BST）和平衡查找树（AVL）"><a href="#5-2-2-二分查找树（BST）和平衡查找树（AVL）" class="headerlink" title="5.2.2 二分查找树（BST）和平衡查找树（AVL）"></a>5.2.2 二分查找树（BST）和平衡查找树（AVL）</h4><p><strong>平衡二叉树：</strong>首先符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1。</p>
<p>平衡二叉树的查询速度快，但是维护代价较大。通过需要1次或多次左旋和右旋来确保AVL树的平衡性。</p>
<h3 id="5-3-B-树"><a href="#5-3-B-树" class="headerlink" title="5.3 B+ 树"></a>5.3 B+ 树</h3><p><strong>B+ 树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。</strong>在 B+ 树中，所有记录节点都是<strong>按键值的大小顺序存放在同一层的叶子节点上</strong>，由各叶子节点指针进行连接。</p>
<h4 id="5-3-1-B-树的插入操作"><a href="#5-3-1-B-树的插入操作" class="headerlink" title="5.3.1 B+ 树的插入操作"></a>5.3.1 B+ 树的插入操作</h4><p>三种情况，涉及三种插入算法：</p>
<ol>
<li>Leaf Page 不满，Index Page 不满</li>
<li>Leaf Page 满，Index Page 不满</li>
<li>Leaf Page 满，Index Page 满</li>
</ol>
<p>2,3 都涉及拆分页的操作，应在可能的情况下尽量减少页的拆分操作。B+ 树提供了类似于 AVL 树的旋转功能减少页的拆分。</p>
<h4 id="5-3-2-B-树的删除操作"><a href="#5-3-2-B-树的删除操作" class="headerlink" title="5.3.2 B+ 树的删除操作"></a>5.3.2 B+ 树的删除操作</h4><p>B+ 树使用填充因子来控制树的删除变化，50%是填充因子可设的最小值。也分为三种情况：</p>
<ol>
<li>叶子节点 &gt; 填充因子，中间结点 &gt; 填充因子。</li>
<li>叶子节点 &lt; 填充因子，中间结点 &gt; 填充因子。</li>
<li>叶子节点 &lt; 填充因子，中间结点 &lt; 填充因子。</li>
</ol>
<p>可参考原书 p187-p191</p>
<h3 id="5-4-B-树索引"><a href="#5-4-B-树索引" class="headerlink" title="5.4 B+ 树索引"></a>5.4 B+ 树索引</h3><p>在第4章 段 中提及。</p>
<p>在数据库中，B+ 树的高度一般都在2 ~ 4 层。</p>
<p>数据库中的 B+  树索引可以分为<strong>聚集索引（clustered index）</strong>和<strong>辅助索引（secondary index）</strong>。聚集索引与辅助索引不同的是，叶子节点存放的是不是一整行的信息。</p>
<h4 id="5-4-1-聚集索引"><a href="#5-4-1-聚集索引" class="headerlink" title="5.4.1 聚集索引"></a>5.4.1 聚集索引</h4><p>聚集索引根据每张表的主键构造一棵 B+ 树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为<strong>数据页</strong>。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分（因为要先利用数据去找到叶子节点）。每个数据页都通过一个双向链表进行连接。</p>
<p>查询优化器倾向于采用聚集索引。因为聚集索引能够在 B+  树索引的叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够很快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描。</p>
<p>数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。</p>
<p>聚集索引的存储<strong>并不是</strong>物理上连续的，而是逻辑连续的。</p>
<p>聚集索引对于主键的排序查找和范围查找速度很快。</p>
<ul>
<li><a href="https://www.cnblogs.com/s-b-b/p/8334593.html" target="_blank" rel="noopener">聚集索引与辅助索引的区别</a></li>
</ul>
<h4 id="5-4-2-辅助索引"><a href="#5-4-2-辅助索引" class="headerlink" title="5.4.2 辅助索引"></a>5.4.2 辅助索引</h4><p>也称非聚集索引，<strong>叶子节点并不包含行记录的全部数据</strong>。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个<strong>书签</strong>。该书签用来告诉 InnoDB 存储引擎哪里可以找到与索引相对应的行数据。</p>
<h4 id="5-4-3-B-树索引的分裂"><a href="#5-4-3-B-树索引的分裂" class="headerlink" title="5.4.3 B+ 树索引的分裂"></a>5.4.3 B+ 树索引的分裂</h4><h4 id="5-4-4-B-树索引的管理"><a href="#5-4-4-B-树索引的管理" class="headerlink" title="5.4.4 B+ 树索引的管理"></a>5.4.4 B+ 树索引的管理</h4><ol>
<li>索引管理</li>
</ol>
<p>在非高峰时期，对应用程序下的几张核心表做 ANALYZE TABLE 操作，使得优化器和索引更好地工作。</p>
<ol start="2">
<li>Fast Index Creation（FIC）</li>
</ol>
<p>让InnoDB避免创建临时表，只限定于辅助索引，对于主键的创建和删除同样需要重建一张表。</p>
<ol start="3">
<li>Online Schema Change（OSC-在线架构改变）</li>
<li>Online DDL</li>
</ol>
<h3 id="5-5-Cardinality-值"><a href="#5-5-Cardinality-值" class="headerlink" title="5.5 Cardinality 值"></a>5.5 Cardinality 值</h3><h4 id="5-5-1-什么是-Cardinality"><a href="#5-5-1-什么是-Cardinality" class="headerlink" title="5.5.1 什么是 Cardinality"></a>5.5.1 什么是 Cardinality</h4><p>并不是在所有的查询条件中出现的列都需要添加索引。对于什么时候添加 B+ 树索引，一般的经验是，在<strong>访问表中很少一部分时使用 B+ 树索引</strong>才有意义。</p>
<p>对于性别字段、地区字段、类型字段，他们可能的取值范围很小，称为<strong>低选择性</strong>。</p>
<p>若取值范围很广，几乎没有重复，即属于<strong>高选择性</strong>，此时使用 B+  树索引是最适合的。例如，姓名字段。</p>
<p>可以通过 SHOW INDEX 结果中的列 Cardinality 来观察。<strong>Cardinality 值非常关键，表示索引中不重复记录数量的预估值。</strong>实际应用中，Cardinality / n_rows_in_table 应该尽可能接近1。</p>
<h4 id="5-5-2-InnoDB-存储引擎的-Cardinality-统计"><a href="#5-5-2-InnoDB-存储引擎的-Cardinality-统计" class="headerlink" title="5.5.2 InnoDB 存储引擎的 Cardinality 统计"></a>5.5.2 InnoDB 存储引擎的 Cardinality 统计</h4><h3 id="5-6-B-树索引的使用"><a href="#5-6-B-树索引的使用" class="headerlink" title="5.6 B+ 树索引的使用"></a>5.6 B+ 树索引的使用</h3><h4 id="5-6-1-不同应用中-B-树索引的使用"><a href="#5-6-1-不同应用中-B-树索引的使用" class="headerlink" title="5.6.1 不同应用中 B+ 树索引的使用"></a>5.6.1 不同应用中 B+ 树索引的使用</h4><ol>
<li>OLTP（On-Line Transaction Processing）应用</li>
</ol>
<p>在 OLTP 中，查询操作只从数据库中取得一小部分数据，一般可能只在10条以下，甚至一条。如根据主键值来获得用户信息，根据订单号获得详细的订单信息。这种情况下，B+ 树索引建立后，对该索引的使用应该只是<strong>通过该索引取得表中少部分的数据</strong>。这时建立 B+ 树索引才是有意义的。</p>
<ol start="2">
<li>OLAP（On-Line Analytical Processing）应用</li>
</ol>
<p>访问表中大量数据，根据数据来产生查询结果，查询多是面向分析的查询，目的是为决策者提供支持。</p>
<h4 id="5-6-2-联合索引"><a href="#5-6-2-联合索引" class="headerlink" title="5.6.2 联合索引"></a>5.6.2 联合索引</h4><p>联合索引是指对表上的多个列进行索引。创建方法与单个索引的创建方法一致，不同之处在于有多个索引列。</p>
<p>联合索引的一个好处是已经对<strong>第二个键值</strong>进行了排序处理。例如，在很多情况下，应用程序需要查询某个用户的购物情况，并按照时间排序，最后取出最近三次的购买记录，这时使用联合索引可以避免多一次排序操作，因为索引本身在叶子节点已经排序了。</p>
<p>举例，联合索引（a,b）是根据 a，b 进行排序的，在 a 一定的情况下，b 是排序的。又如，联合索引（a，b，c）是根据 a，b，c 排序的，在 a，b 一定的情况下，c 是排序的，但是在 a 一定的情况下，c 不一定是排序的，还需要再执行一次 filesort操作将 c 排序。在查询中可用。</p>
<h4 id="5-6-3-覆盖索引"><a href="#5-6-3-覆盖索引" class="headerlink" title="5.6.3 覆盖索引"></a>5.6.3 覆盖索引</h4><p>覆盖索引（covering index），即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。好处是，辅助索引不包含整行记录的所有信息，所以其大小远小于聚集索引，能减少大量 IO 操作。</p>
<p>覆盖索引的另一个好处是针对某些统计问题而言的。Using index 就是代表了优化器进行了覆盖索引操作。</p>
<p>❤：<strong>联合索引和覆盖索引都是辅助索引的应用。</strong></p>
<h4 id="5-6-4-优化器选择不使用索引的情况"><a href="#5-6-4-优化器选择不使用索引的情况" class="headerlink" title="5.6.4 优化器选择不使用索引的情况"></a>5.6.4 优化器选择不使用索引的情况</h4><p>使用 EXPLAIN 命令进行 SQL 分析时，会发现优化器并没有选择索引去查找数据，而是通过扫描聚集索引，也就是直接进行全表的扫描。</p>
<p>多发生于<strong>范围查找，JOIN 链接操作</strong>等情况。</p>
<h4 id="5-6-5-索引提示"><a href="#5-6-5-索引提示" class="headerlink" title="5.6.5 索引提示"></a>5.6.5 索引提示</h4><h4 id="5-6-6-Multi-Range-Read-优化"><a href="#5-6-6-Multi-Range-Read-优化" class="headerlink" title="5.6.6 Multi-Range Read 优化"></a>5.6.6 Multi-Range Read 优化</h4><h4 id="5-6-7-Index-Condition-PushDown（ICP）优化"><a href="#5-6-7-Index-Condition-PushDown（ICP）优化" class="headerlink" title="5.6.7 Index Condition PushDown（ICP）优化"></a>5.6.7 Index Condition PushDown（ICP）优化</h4><h3 id="5-7-哈希算法"><a href="#5-7-哈希算法" class="headerlink" title="5.7 哈希算法"></a>5.7 哈希算法</h3><h4 id="5-7-1-哈希表"><a href="#5-7-1-哈希表" class="headerlink" title="5.7.1 哈希表"></a>5.7.1 哈希表</h4><p>多个关键字映射到一个槽上称之为碰撞，数据库中采用最简单的碰撞解决技术，<strong>链接法</strong>。</p>
<p>链接法把散列到同一个槽中的元素都放在一个列表中，槽 j 中有一个指针，指向由所有映射到槽 j 的元素构成的链表的链表头，如果不存在这样的元素，就为 NULL</p>
<p>数据库中一般采用<strong>除法散列</strong>的方法。</p>
<p>将 k 映射到 m 个槽中。h(k) = k mod m</p>
<h4 id="5-7-2-哈希函数"><a href="#5-7-2-哈希函数" class="headerlink" title="5.7.2 哈希函数"></a>5.7.2 哈希函数</h4><p>对于缓冲池中的页，在缓冲池中的 Page 页都有一个 chain 指针，指向相同哈希函数值的页。对于除法散列，<strong>m 的取值为略大于2倍的缓冲池页数量的质数</strong>。</p>
<p>InnoDB 存储引擎的缓冲池对于其中的页是怎么进行查找的？</p>
<p>答：InnoDB 存储引擎的表空间都有一个 space_id，用户所有查询的应是某个表空间的某个连续16KB 的页，即偏移量 offset。InnoDB 将 space_id 左移20位，然后加上这个 space_id 和 offset，即<strong>关键字 K = space_id &lt;&lt; 20 + space_id + offset</strong>，然后通过除法散列到各个槽中去。</p>
<h4 id="5-7-3-自适应哈希索引"><a href="#5-7-3-自适应哈希索引" class="headerlink" title="5.7.3 自适应哈希索引"></a>5.7.3 自适应哈希索引</h4><p>只适用于<strong>等值查询</strong>，如 Select * from table where index_col = “xxx”；</p>
<p>不适用于范围查询。</p>
<p>该索引由 InnoDB 存储引擎自身控制。</p>
<h3 id="5-8-全文检索"><a href="#5-8-全文检索" class="headerlink" title="5.8 全文检索"></a>5.8 全文检索</h3><h4 id="5-8-1-概述"><a href="#5-8-1-概述" class="headerlink" title="5.8.1 概述"></a>5.8.1 概述</h4><p>搜索引擎需要根据用户输入的关键词进行全文查找等；</p>
<p><strong>全文检索（Full-Text Search）是将存储于数据库中的整本书或整片文章中的任意内容信息查找出来的技术。</strong>它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。</p>
<h4 id="5-8-2-倒排索引"><a href="#5-8-2-倒排索引" class="headerlink" title="5.8.2 倒排索引"></a>5.8.2 倒排索引</h4><p>全文检索通常使用倒排索引实现。同 B+ 树索引一样，也是一种索引结构。它在辅助表中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。有两种表现形式：</p>
<ul>
<li>inverted file index：{单词，单词所在文档的ID}</li>
<li>full inverted index：{单词，（单词所在文档ID，在具体文档中的位置）}</li>
</ul>
<p>full inverted index 占用更多空间，但能更好的定位数据，并扩展搜索功能。</p>
<h4 id="5-8-3-InnoDB-全文检索"><a href="#5-8-3-InnoDB-全文检索" class="headerlink" title="5.8.3 InnoDB 全文检索"></a>5.8.3 InnoDB 全文检索</h4><p>采用 full inverted index，将 （DocumentID,  Position）看作一个“ilist”。</p>
<p>为了提高全文检索的并行性能，InnoDB 共有6张辅助表，每张表根据 word 的 latin 编码进行分区。</p>
<p>辅助表都是持久的表，存放于磁盘上。</p>
<p>FTS Index Cache 全文检索索引缓存，用来提高全文检索的性能，采用红黑树结构，根据 (word, ilist) 进行排序。</p>
<p>InnoDB 全文检索目前的限制：</p>
<ol>
<li>每张表只能有一个全文检索的索引；</li>
<li>由多列组合而成的全文检索的索引列必须使用相同的字符集与排序规则；</li>
<li>不支持没有单词界定符的语言，如中文，日韩语</li>
</ol>
<h4 id="5-8-4-全文检索"><a href="#5-8-4-全文检索" class="headerlink" title="5.8.4 全文检索"></a>5.8.4 全文检索</h4><p>MySQL 数据库使用 MATCH（）。。。AGAINST（）语法支持全文检索的查询</p>
<p>语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (col1,col2,...) AGAINST (expr [search_modifier])</span><br><span class="line">search_modifier:</span><br><span class="line">&#123;</span><br><span class="line">	IN NATURAL LANGUAGE MODE</span><br><span class="line">	| IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION</span><br><span class="line">	| IN BOOLEAN MODE</span><br><span class="line">	| WITH QUERY EXPANSION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为3中查询模式：</p>
<ol>
<li>Natural Language</li>
<li>Boolean</li>
<li>Query Expansion</li>
</ol>
<hr>
<h2 id="第6章-锁"><a href="#第6章-锁" class="headerlink" title="第6章 锁"></a>第6章 锁</h2><p>人们认为行级锁总会增加开销，实际上，只有当实现本身会增加开销时，行级锁才会增加开销。InnoDB 存储引擎不需要锁升级，因为一个锁和多个锁的开销是一样的。</p>
<h3 id="6-1-什么是锁"><a href="#6-1-什么是锁" class="headerlink" title="6.1 什么是锁"></a>6.1 什么是锁</h3><p>数据库系统使用锁是为了支持对<strong>共享资源</strong>的并发访问，提供数据的完整性和一致性。</p>
<p>InnoDB 存储引擎锁的实现和 Oracle 数据库非常类似，都提供<strong>一致性的非锁定读、行级锁支持</strong>。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。</p>
<h3 id="6-2-lock-与-latch"><a href="#6-2-lock-与-latch" class="headerlink" title="6.2 lock 与 latch"></a>6.2 lock 与 latch</h3><ol>
<li>latch 一般称为“闩(shuan)锁”（轻量级锁）</li>
</ol>
<p>因为其要求锁定的时间非常短。若持续的时间长，应用的性能会非常差。InnoDB 存储引擎中。latch 又可以分为 mutex（互斥量）和 rwlock（读写锁）。<strong>目的是用来保证并发线程操作临界资源的正确性，通常没有死锁检测机制。</strong></p>
<ol start="2">
<li>lock（本节关注对象）</li>
</ol>
<p>对象是事务，用来锁定的是数据库中的对象，如表，页，行。且 lock 的对象仅在事务 commit 或 rollback 后进行释放，有死锁机制。</p>
<ol start="3">
<li>lock 与 latch 的比较</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">lock</th>
<th align="center">latch</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>对象</strong></td>
<td align="center">事务</td>
<td align="center">线程</td>
</tr>
<tr>
<td align="center"><strong>保护</strong></td>
<td align="center">数据库内容</td>
<td align="center">内存数据结构</td>
</tr>
<tr>
<td align="center"><strong>持续时间</strong></td>
<td align="center">整个事务过程</td>
<td align="center">临界资源</td>
</tr>
<tr>
<td align="center"><strong>模式</strong></td>
<td align="center">行锁、表锁、意向锁</td>
<td align="center">mutex、rwlock</td>
</tr>
<tr>
<td align="center"><strong>死锁</strong></td>
<td align="center">死锁检测与处理</td>
<td align="center">无。仅通过应用程序加锁的顺序保证无死锁的发生</td>
</tr>
<tr>
<td align="center"><strong>存在于</strong></td>
<td align="center">Lock Manager 的哈希表中</td>
<td align="center">每个数据结构的对象中</td>
</tr>
</tbody></table>
<h3 id="6-3-InnoDB-存储引擎中的锁"><a href="#6-3-InnoDB-存储引擎中的锁" class="headerlink" title="6.3 InnoDB 存储引擎中的锁"></a>6.3 InnoDB 存储引擎中的锁</h3><h4 id="6-3-1-锁的类型"><a href="#6-3-1-锁的类型" class="headerlink" title="6.3.1 锁的类型"></a>6.3.1 锁的类型</h4><p>如下两种标准的行级锁：</p>
<ul>
<li>共享锁（S Lock），允许事务读一行数据；</li>
<li>排它锁（X Lock），允许事务删除或更新一行数据。</li>
</ul>
<p>如果一个事务 T1 已经获得 记录 r 的共享锁，那么事务 T2 可以立即获得行 r 的共享锁，因为读取并没有改变行 r 的数据，称这种情况为<strong>锁兼容</strong>。但若有事务 T3 想获得行 r 的排它锁，则必须等待事务 T1, T2 释放行 r 上的共享锁——这种情况称为<strong>锁不兼容</strong>。<strong>兼容是指对同一行记录锁的兼容性情况。</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">X</th>
<th align="center">S</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<p>InnoDB 支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。InnoDB 支持意向锁。<strong>意向锁</strong>是指将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="层次结构"></p>
<p>如上图，如果想对最细粒度的对象进行上锁，那么需要首先对粗粒度的对象上锁。</p>
<p>举例：如需要对页上的记录 r 进行上 X 锁，那么需要先对数据库A、表页上意向锁 IX，最后对记录 r 上 X 锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录 r 加 X 锁之前，已经有事务对表1进行了 S 表锁，那么表1就已经存在 S 锁，之后事务需要对记录 r 在表1上加上 IX 锁，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
<p>意向锁即为表级别的锁，<strong>设计目的是为了在一个事务中揭示下一行将被请求的锁类型。</strong></p>
<ol>
<li>意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁；</li>
<li>意向排它锁（IX Lock）：事务想要获得一张表中某几行的排它锁；</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">IS</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">X</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>IS</strong></td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><strong>IX</strong></td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><strong>S</strong></td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><strong>X</strong></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
</tbody></table>
<p><strong>由于 InnoDB 支持的是行级别的锁，所以意向锁其实不会阻塞除全表扫以外的任何请求。</strong></p>
<h4 id="6-3-2-一致性非锁定读"><a href="#6-3-2-一致性非锁定读" class="headerlink" title="6.3.2 一致性非锁定读"></a>6.3.2 一致性非锁定读</h4><p>consistent nonlocking read 是指 InnoDB 通过行多版本控制的方式来读取当前执行时间数据库中的数据。如果读取的行正在进行 DELETE 或 UPDATE 操作，这时读取操作不会因此去等待行上锁的释放。相反，会去读取行的一个快照数据。</p>
<p><strong>快照数据</strong>是指该行的之前版本的数据，该实现是通过 undo 段来完成。undo 用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据不需要上锁，因为没有事务需要对历史的数据进行修改操作。</p>
<p>InnoDB 默认读取方式，即读取不会占用和等待表上的锁</p>
<p>一个行记录可能有多个快照数据，一般称这种技术为行多版本技术，由此带来的并发控制，称之为<strong>多版本并发控制</strong>（Multi Version Concurrency Control）</p>
<p>在事务隔离级别 READ COMMITED 和 REPEATABLE READ （InnoDB 默认隔离级别）下，InnoDB使用非锁定的一致性读。但对于快照数据的定义不同：</p>
<ul>
<li><strong>READ COMMITED 事务隔离级别下，非一致性读总是读取被锁定行的最新一份快照数据；</strong></li>
<li><strong>REPEATABLE READ 事务隔离级别下，非一致性读总是读取事务开始时的行数据版本。</strong></li>
</ul>
<h4 id="6-3-3-一致性锁定读"><a href="#6-3-3-一致性锁定读" class="headerlink" title="6.3.3 一致性锁定读"></a>6.3.3 一致性锁定读</h4><p>在某些情况下，用户需要显示地对数据库读取操作进行加锁以保证数据逻辑的一致性。要求数据库支持加锁语句，即使是对 SELECT 的只读操作。两种一致性锁定读：</p>
<ul>
<li>SELECT…FOR UPDATE</li>
<li>SELECT…LOCK IN SHARE MODE</li>
</ul>
<p>SELECT…FOR UPDATE 对读取的行记录加一个 X 锁；</p>
<p>SELECT…LOCK IN SHARE MODE 对读取的行记录加一个 S 锁。</p>
<p>当事务提交了，锁也就释放了。</p>
<h4 id="6-3-4-自增长与锁"><a href="#6-3-4-自增长与锁" class="headerlink" title="6.3.4 自增长与锁"></a>6.3.4 自增长与锁</h4><p>InnoDB 内存结构中，对每一个含有自增长值的表都有一个自增长计数器。插入操作会依据这个自增长的计数器增加1赋予自增长列，这个实现方式称作 AUTO-INC Locking，这种锁采用特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后释放，而是在完成对自增长值插入的SQL语句后立即释放。</p>
<h4 id="6-3-5-外键和锁"><a href="#6-3-5-外键和锁" class="headerlink" title="6.3.5 外键和锁"></a>6.3.5 外键和锁</h4><h3 id="6-4-锁的算法"><a href="#6-4-锁的算法" class="headerlink" title="6.4 锁的算法"></a>6.4 锁的算法</h3><h4 id="6-4-1-行锁的3种算法"><a href="#6-4-1-行锁的3种算法" class="headerlink" title="6.4.1 行锁的3种算法"></a>6.4.1 行锁的3种算法</h4><ul>
<li>Record Lock：单个行记录上的锁；</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身；</li>
<li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，且锁定记录本身。</li>
</ul>
<p>当查询的索引含有唯一属性时，InnoDB 会对 Next-Key Lock 进行优化，降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<h4 id="6-4-2-解决-Phantom-Problem"><a href="#6-4-2-解决-Phantom-Problem" class="headerlink" title="6.4.2 解决 Phantom Problem"></a>6.4.2 解决 Phantom Problem</h4><p>在默认事务隔离级别下，即 REPEATABLE READ下，InnoDB 采用 Next-Ley Locking 机制来避免 Phantom Problem（幻象问题）。</p>
<p><strong>Phantom Problem 是指：在同一事务下，连续执行两次同样的 SQL 语句可能导致不同的结果，第二次的 SQL 语句可能会返回之前不存在的行。</strong></p>
<h3 id="6-5-锁问题"><a href="#6-5-锁问题" class="headerlink" title="6.5 锁问题"></a>6.5 锁问题</h3><p>锁只会带来三种问题，如果可以防止这三种情况的发生，那就不会出现并发异常。</p>
<h4 id="6-5-1-脏读"><a href="#6-5-1-脏读" class="headerlink" title="6.5.1 脏读"></a>6.5.1 脏读</h4><p><strong>脏页：</strong>指在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘中的页的数据是不一致的，当然在刷新到磁盘之前，日志都已经被写入到了重做日志文件中。数据库实例内存与磁盘的异步造成的，不影响数据一致性。脏页的刷新是异步的，带来性能提升。</p>
<p><strong>脏数据：</strong>事务对缓冲池中行记录的修改，并且还没有被提交。如果读到了脏数据，即一个事务可以读到另一个事务中还未提交的数据，则显然违反了数据库的隔离性。</p>
<p><strong>脏读：</strong>可以读到脏数据。</p>
<p>脏读需要事务的隔离级别为 READ UNCOMMITTED，InnoDB 默认 REPEATABLE READ。</p>
<h4 id="6-5-2-不可重复读"><a href="#6-5-2-不可重复读" class="headerlink" title="6.5.2 不可重复读"></a>6.5.2 不可重复读</h4><p>在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了一个事务内两次读到的数据是不一样的情况 ，称为不可重复读。</p>
<p><strong>脏读读到的是未提交的数据，不可重复读读到的是已提交的数据，但是违反了事务一致性的要求。</strong></p>
<p>InnoDB 的默认事务隔离级别是 REPEATABLE READ，采用 Next-Key Lock算法，避免了不可重复读。</p>
<h4 id="6-5-3-丢失更新"><a href="#6-5-3-丢失更新" class="headerlink" title="6.5.3 丢失更新"></a>6.5.3 丢失更新</h4><p>一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。</p>
<p>要避免丢失更新，需要让事务在这种情况下的操作变成串行化，而不是并行操作。</p>
<h3 id="6-7-死锁"><a href="#6-7-死锁" class="headerlink" title="6.7 死锁"></a>6.7 死锁</h3><h4 id="6-7-1-死锁的概念"><a href="#6-7-1-死锁的概念" class="headerlink" title="6.7.1 死锁的概念"></a>6.7.1 死锁的概念</h4><p><strong>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。</strong></p>
<p>两种解决办法：</p>
<ol>
<li><strong>设置超时</strong></li>
</ol>
<p>当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_lock_wait_timeout 设置超时时间</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>wait-for graph（等待图），InnoDB 采用</strong></li>
</ol>
<p>要求数据库保持以下两种信息</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<p>根据上述链表可以构造出一张有向图，若在这个图中存在回路，就代表存在死锁。InnoDB 通常选择回滚 undo 量最小的事务。深度优先算法实现。</p>
<h3 id="6-8-锁升级"><a href="#6-8-锁升级" class="headerlink" title="6.8 锁升级"></a>6.8 锁升级</h3><p>InnoDB 不存在锁升级的问题，因为其不是根据每个记录来产生行锁的，是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。</p>
<hr>
<h2 id="第7章-事务"><a href="#第7章-事务" class="headerlink" title="第7章 事务"></a>第7章 事务</h2><p>引入事务的目的：<strong>事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，那么所有修改都不保存。</strong></p>
<p>InnoDB 中的事务完全符合 ACID 的特性：</p>
<ul>
<li><strong>原子性（Atomicity）</strong></li>
<li><strong>一致性（Consistency）</strong></li>
<li><strong>隔离性（Isolation）</strong></li>
<li><strong>持久性（Durability）</strong></li>
</ul>
<h3 id="7-1-事务"><a href="#7-1-事务" class="headerlink" title="7.1 事务"></a>7.1 事务</h3><h4 id="7-1-1-概念"><a href="#7-1-1-概念" class="headerlink" title="7.1.1 概念"></a>7.1.1 概念</h4><p>在事务中的操作，要么都做修改，要么都不做。</p>
<p>InnoDB 默认的事务隔离级别 REPEATABLE READ 完全遵循和满足事务的 ACID 性。</p>
<ul>
<li><strong>原子性</strong></li>
</ul>
<p>指整个数据库事务是不可分割的工作单位。只有使事务中的所有数据库操作都执行成功，才算整个事务成功。事务中任何一个 SQL 语句执行失败，已经执行成功的 SQL 语句也必须撤销，数据库状态应该退回到执行事务前的状态。</p>
<ul>
<li><strong>一致性</strong></li>
</ul>
<p>事务开始前和结束后，数据库的完整性约束没有被破坏。事务是一致性的单位，如果事务中某个动作失败了，系统可以自动撤销事务——范围初始化的状态。</p>
<ul>
<li><strong>隔离性</strong>（又称：并发控制、可串行化、锁）</li>
</ul>
<p>事务提交前对其他事务都不可见，通常用锁来实现。</p>
<ul>
<li><strong>持久性</strong></li>
</ul>
<p>事务一旦提交，其结果就是永久性的。即使发生宕机故障，数据库也能够将数据恢复。</p>
<h4 id="7-1-2-分类"><a href="#7-1-2-分类" class="headerlink" title="7.1.2 分类"></a>7.1.2 分类</h4><ul>
<li>扁平事务</li>
<li>带有保存点的扁平事务</li>
<li>链事务</li>
<li>嵌套事务</li>
<li>分布式事务</li>
</ul>
<h3 id="7-2-事务的实现"><a href="#7-2-事务的实现" class="headerlink" title="7.2 事务的实现"></a>7.2 事务的实现</h3><p>redo log 称为重做日志，用来保证事务的原子性和持久性。undo log 用来保证事务的一致性。锁保证事务的隔离性。</p>
<p>redo 和 undo 的作用都可以视为一种恢复操作，redo 恢复提交事务修改的页操作，undo 回滚行记录到某个特定版本。</p>
<p>redo 通常是物理日志，记录的是页的物理修改操作；undo 是逻辑日志，根据每行记录进行记录。</p>
<h4 id="7-2-1-redo"><a href="#7-2-1-redo" class="headerlink" title="7.2.1 redo"></a>7.2.1 redo</h4><ol>
<li>基本概念</li>
</ol>
<p><strong>①内存中的重做日志缓冲，易失；②重做日志文件，持久的；</strong></p>
<p>持久化，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的提交（commit）操作完成才算完成。</p>
<p>为确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件后，InnoDB 都需要调用一次 <strong>fsync</strong> 操作。由于重做日志文件打开并没有使用 O_DIRECT 选项，因此重做日志缓冲先写入文件系统缓存，为了确保重做日志写入磁盘，必须进行一次 <strong>fsync</strong> 操作。磁盘的性能决定了提交事务的性能，也就是数据库的性能。</p>
<p>也可以手工设置非持久化的情况发生，提高数据库性能，即设置等待一个周期才进行 <strong>fsync</strong> 操作，但当数据库发生宕机时，由于部分日志未刷新到磁盘，会丢失部分为刷新到磁盘的事务。</p>
<ol start="2">
<li>log block</li>
</ol>
<p>InnoDB 中，重做日志都是以512字节进行存储的。故，重做日志缓冲，重做日志文件都是以<strong>块</strong>方式进行保存的，称之为重做日志块。</p>
<h4 id="7-2-2-undo"><a href="#7-2-2-undo" class="headerlink" title="7.2.2 undo"></a>7.2.2 undo</h4><ol>
<li>基本概念</li>
</ol>
<p>undo 存放在数据库内部的一个特殊段中，称为 undo 段，位于共享表空间中。</p>
<p>在对数据库进行修改时，不但会产生 redo，还会产生一定量的 undo。</p>
<p>undo log 的产生会伴随 redo log 的产生，因为undo log 也需要持久化的保护。</p>
<h3 id="7-6-事务的隔离级别"><a href="#7-6-事务的隔离级别" class="headerlink" title="7.6 事务的隔离级别"></a>7.6 事务的隔离级别</h3><p>SQL 标准定义的四种隔离级别为：</p>
<ol>
<li><strong>READ UNCOMMITTED</strong></li>
<li><strong>READ COMMITTED</strong></li>
<li><strong>REPEATABLE READ</strong></li>
<li><strong>SERIALIZABLE</strong></li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构-堆与堆排序</title>
    <url>/2019/10/16/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>堆与堆排序</p>
<a id="more"></a>

<h2 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h2><h3 id="1-构造堆的几种方式"><a href="#1-构造堆的几种方式" class="headerlink" title="1. 构造堆的几种方式"></a>1. 构造堆的几种方式</h3><ol>
<li>向一个容量为 capacity 的堆中逐个插入元素，构造最大堆</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 堆索引从 1 开始，所以第 0 个空间浪费掉</span></span><br><span class="line">        data = <span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入可比较的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确保这一次能够添加成功，最好能够动态分配空间</span></span><br><span class="line">        <span class="keyword">assert</span> count + <span class="number">1</span> &lt;= capacity;</span><br><span class="line">        data[count + <span class="number">1</span>] = v;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="comment">// 因为新元素的添加可能导致整个堆的性质发生改变，</span></span><br><span class="line">        <span class="comment">// 所以我们将 count 这个位置的元素进行“上移”操作</span></span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要确保索引范围，在这里，索引为2时，就是去和索引为1的节点(根节点)进行比较</span></span><br><span class="line">        <span class="comment">// 如父节点小于子节点，则进行交换操作</span></span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; SortUtil.less(data[index / <span class="number">2</span>], data[index])) &#123;</span><br><span class="line">            SortUtil.swap(data, parent(index), index);</span><br><span class="line">            index /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出堆中最大的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> count &gt; <span class="number">0</span>;</span><br><span class="line">        Comparable ret = data[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 先将第 1 个元素与第 count 个元素交换位置，然后对第 1 个元素进行“下移”操作</span></span><br><span class="line">        SortUtil.swap(data, <span class="number">1</span>, count);</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对索引为 index 的元素执行下沉操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若子节点存在且找出最大的子节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * index &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * index;<span class="comment">// 此轮循环中，data[index] 应该和 data[j] 交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; SortUtil.less(data[j], data[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 右孩子存在且右孩子大于左孩子</span></span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!SortUtil.less(data[index], data[j])) <span class="keyword">break</span>;</span><br><span class="line">            SortUtil.swap(data, index, j);</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时，堆排序，相当于将一个堆中的最大值取出来后反向赋值，构造一个递增序列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort1</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        MaxHeap maxHeap = <span class="keyword">new</span> MaxHeap(n);、</span><br><span class="line">        <span class="comment">// 将 arr 中元素挨个插入最大堆中进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            maxHeap.insert(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">// 反向赋值，最大值放到数组最后面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) &#123;</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在创建最大堆对象时，直接将一个数组构造为最大堆，免去插入操作，一定程度上提高效率，因为只对一半的元素进行了下移操作（第12-14行）；<strong>给定一个数组，让其形成最大堆的形状的过程称为 ==“heapify”==。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// 给定一个数组，让其形成堆的形状的过程： heapify</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Comparable[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;</span><br><span class="line">            data[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="comment">// 对于第 [count / 2 + 1,count] 的元素，没有子节点了，已经是一个最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count / <span class="number">2</span>;i &gt;= <span class="number">1</span>;i --) &#123;</span><br><span class="line">            shiftDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对索引为 index 的元素执行下沉操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 见上一节 40 行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出堆中最大的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 见上一节 30 行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort2</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用构造函数让这个堆直接成为一个最大堆</span></span><br><span class="line">        MaxHeap maxHeap = <span class="keyword">new</span> MaxHeap(arr, n);</span><br><span class="line">        <span class="comment">// 输出一个最大堆中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) &#123;</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不使用额外的空间，在原数组上进行最大堆堆排序。在最大堆中，先将最大元素交换到数组最后，然后对前 n - 1 个元素再次进行查找最大元素的操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引从 0 开始 heapify</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>;i --) &#123;</span><br><span class="line">            shiftDown(arr, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt; <span class="number">0</span>;i --) &#123;</span><br><span class="line">            <span class="comment">// 第 0 个元素无需排序，就在第 0 个位置了</span></span><br><span class="line">            <span class="comment">// 把当前堆中最大元素放到最后</span></span><br><span class="line">            SortUtil.swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 对堆中剩下的 i 个元素中的第 0 个元素进行下沉操作</span></span><br><span class="line">            shiftDown(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对arr中n个元素中的第 index 个元素进行下沉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * index + <span class="number">1</span>; <span class="comment">// 在此轮循环中，arr[index] 和 arr[j] 交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; SortUtil.less(arr[j], arr[j + <span class="number">1</span>]))</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!SortUtil.less(arr[index], arr[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SortUtil.swap(arr, j, index);</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2. 时间复杂度"></a>2. 时间复杂度</h3><blockquote>
<p>N log N</p>
</blockquote>
<h2 id="最大索引堆"><a href="#最大索引堆" class="headerlink" title="最大索引堆"></a>最大索引堆</h2><blockquote>
<p>当要参与比较的元素是很复杂的结构的时候，每一次交换操作很耗费时间和空间，所以考虑使用索引来记录每一个待交换元素的位置，这样在交换的时候只需要考虑索引位置，索引是 int 类型，能够提高交换效率。</p>
</blockquote>
<ol>
<li>实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable[] data;</span><br><span class="line">    <span class="keyword">private</span> Integer[] indexes; <span class="comment">// 索引数组</span></span><br><span class="line">    <span class="comment">// reverse[i] 表示索引 i 在 indexes 中的位置</span></span><br><span class="line">    <span class="comment">// indexes[i] = j, reverse[j] = i</span></span><br><span class="line">    <span class="comment">// indexes[reverse[i]] = i; reverse[indexes[i]] = i</span></span><br><span class="line">    <span class="comment">// 反向查找</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] reverse;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">// k 描述的是索引数组的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; SortUtil.less(data[indexes[k / <span class="number">2</span>]], data[indexes[k]])) &#123;</span><br><span class="line">            SortUtil.swap(indexes, k / <span class="number">2</span>, k);</span><br><span class="line">            reverse[indexes[k / <span class="number">2</span>]] = k / <span class="number">2</span>;</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k; <span class="comment">// 此轮循环中，indexes[k] 和 indexes[j]交换位置</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count &amp;&amp; </span><br><span class="line">                SortUtil.less(data[indexes[j]], data[indexes[j + <span class="number">1</span>]])) &#123;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!SortUtil.less(data[indexes[k]], data[indexes[j]]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            SortUtil.swap(indexes, k, j);</span><br><span class="line">            reverse[indexes[k]] = k;</span><br><span class="line">            reverse[indexes[j]] = j;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverse[index + <span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第 0 个位置浪费</span></span><br><span class="line">        data = <span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">        indexes = <span class="keyword">new</span> Integer[capacity + <span class="number">1</span>];</span><br><span class="line">        reverse = <span class="keyword">new</span> Integer[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= capacity;i ++) &#123;</span><br><span class="line">            <span class="comment">// 为 0 表示不存在</span></span><br><span class="line">            reverse[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入的 i 对于用户而言是从 0 索引开始的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Comparable v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count + <span class="number">1</span> &gt; capacity) &#123;</span><br><span class="line">            System.out.println(<span class="string">"堆已满，无法插入！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &lt;= <span class="number">1</span> &amp;&amp; index + <span class="number">1</span> &gt; capacity) &#123;</span><br><span class="line">            System.out.println(<span class="string">"非法的索引！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们内部堆索引从 1 开始，所以先给 index + 1</span></span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        data[index] = v;</span><br><span class="line">        indexes[count + <span class="number">1</span>] = index;</span><br><span class="line">        reverse[index] = count + <span class="number">1</span>;</span><br><span class="line">        count ++;</span><br><span class="line">        shiftUp(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"堆为空！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// indexes[1] 记录最大元素所在的位置</span></span><br><span class="line">        Comparable ret = data[indexes[<span class="number">1</span>]];</span><br><span class="line">        SortUtil.swap(indexes, <span class="number">1</span>, count);</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引堆特有，找到最大元素的索引，那么根据这个索引，我们就能够找到这个最大的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">extractMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"堆为空！"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对外部来说，index是从0开始的</span></span><br><span class="line">        Integer ret = indexes[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        SortUtil.swap(indexes, <span class="number">1</span>, count);</span><br><span class="line">        reverse[indexes[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        reverse[indexes[count]] = <span class="number">0</span>;</span><br><span class="line">        count --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">contain</span><span class="params">(index)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改堆中索引 index 处的元素为 v</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> index, Comparable v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确保这个堆包含该索引</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">contain</span><span class="params">(index)</span></span>;</span><br><span class="line"></span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        data[index] = v;</span><br><span class="line">        <span class="comment">// 找到 indexes[j] = index, j 代表 data[index] 在堆中的位置</span></span><br><span class="line">        <span class="comment">// 之后 shiftUp(j),再 shiftDown(j)</span></span><br><span class="line"><span class="comment">//        for (int j = 1;j &lt;= count;j ++ )&#123;</span></span><br><span class="line"><span class="comment">//            if (indexes[j] == index) &#123;</span></span><br><span class="line"><span class="comment">//                shiftDown(j);</span></span><br><span class="line"><span class="comment">//                shiftUp(j);</span></span><br><span class="line"><span class="comment">//                break;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 优化后</span></span><br><span class="line">        <span class="keyword">int</span> j = reverse[index];</span><br><span class="line">        shiftUp(j);</span><br><span class="line">        shiftDown(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png" alt="排序算法总结"></p>
<ol>
<li>稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生改变</li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构-排序</title>
    <url>/2019/10/16/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>算法与数据结构</p>
<a id="more"></a>

<h3 id="1-基础排序"><a href="#1-基础排序" class="headerlink" title="1. 基础排序"></a>1. 基础排序</h3><blockquote>
<ol>
<li><strong>选择排序：</strong>时间复杂度 O(n^2)</li>
<li><strong>插入排序：</strong>时间复杂度 O(n^2)，<strong>适用于处理接近排序好的数组，完全排好序的情况下的时间复杂度为 O(n)</strong></li>
<li>希尔排序</li>
</ol>
</blockquote>
<ul>
<li>下列排序算法都适用于实现了 Comparable 接口的数据类型。（Integer，Double，String等引用类型都实现了这个接口，所以在创建数组是需要用这样的引用类型来创建。在创建自己的数据类型时，只要实现 Comparable 接口并重写 compareTo() 方法，自定义排序规则即可。）</li>
</ul>
<h4 id="1-1-选择排序"><a href="#1-1-选择排序" class="headerlink" title="1.1 选择排序"></a>1.1 选择排序</h4><ol>
<li><strong>思路：</strong>不断选择剩下元素中的最小者；</li>
<li><strong>实现：</strong>首先，找到数组中最小的元素（需要遍历一遍数组），然后将它和数组中的第一个元素交换位置；然后，在剩下的元素中找到最小的元素，然后将它和数组中的第二个元素交换位置；循环，直到将整个数组排序。</li>
<li>特点：<ol>
<li>运行时间和输入无关；</li>
<li>数据移动是最少的。</li>
</ol>
</li>
<li><strong>对于长度为 N 的数组，选择排序需要大约 N^2 / 2 次比较和 N 次交换。</strong></li>
<li>代码实现：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 Comparable 接口可以实现多种实现 Comparable 接口类型的元素比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; length;j ++) &#123;</span><br><span class="line">                <span class="comment">// arr[j] &lt; arr[minIndex] 则返回 true</span></span><br><span class="line">                <span class="keyword">if</span> (SortUtil.less(arr[j], arr[minIndex])) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换数组arr中，两个索引位置的元素</span></span><br><span class="line">            SortUtil.swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-插入排序"><a href="#1-2-插入排序" class="headerlink" title="1.2 插入排序"></a>1.2 插入排序</h4><ol>
<li><p>插入排序所需时间与输入元素的初始顺序有关；</p>
<ul>
<li>对一个很大且其中的元素<strong>已经有序（或接近有序）的数组进行排序</strong>将会比对随机顺序或逆序的数组进行排序要<strong>快得多</strong>。</li>
</ul>
</li>
<li><p><strong>对于随机排列的长度为 N 的主键不重复的数组，平均情况下插入排序需要大约 N^2 / 4 次比较和大约 N^2 /  4次交换。最坏情况分母为2；最好情况即完全有序的时候，需要 N - 1次比较和0次交换。</strong></p>
</li>
<li><p>代码实现：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span> &amp;&amp; SortUtil.less(arr[j],arr[j - <span class="number">1</span>]); j --) &#123;</span><br><span class="line">                SortUtil.swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对闭区间 arr[left, right] 的排序，方法的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left;i &lt;= right;i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span> &amp;&amp; SortUtil.less(arr[j], arr[j - <span class="number">1</span>]); j --) &#123;</span><br><span class="line">                SortUtil.swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-希尔排序"><a href="#1-3-希尔排序" class="headerlink" title="1.3 希尔排序"></a>1.3 希尔排序</h4><h3 id="2-高级排序"><a href="#2-高级排序" class="headerlink" title="2. 高级排序"></a>2. 高级排序</h3><h4 id="2-1-归并排序"><a href="#2-1-归并排序" class="headerlink" title="2.1 归并排序"></a>2.1 归并排序</h4><ol>
<li>性质：<ul>
<li><strong>任意长度为 N 的数组排序所需时间和 NlogN 成正比（优点）</strong></li>
<li><strong>所需的额外空间和 N 成正比（缺点）</strong></li>
</ul>
</li>
<li>原地归并的抽象方法：原地归并将子数组 arr[left, mid] 和 arr[mid + 1, right] 归并成一个有序的数组并将结果存放在 arr[left, right] 中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先定义一个辅助数组，存储 arr 的一个拷贝</span></span><br><span class="line">    <span class="comment">// Comparable[] aux = new Comparable[arr.length];</span></span><br><span class="line">    <span class="comment">// 将 aux 设置成员全局变量能够有效减少每一次递归 merge 函数带来的新建对象的开销</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left;i &lt;= right;i ++) &#123;</span><br><span class="line">        aux[i - left] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left;k &lt;= right;k ++) &#123;</span><br><span class="line">        <span class="comment">// 首先对i,j两个索引的越界情况作出判断</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            arr[k] = aux[j - left];</span><br><span class="line">            j ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right) &#123;</span><br><span class="line">            arr[k] = aux[i - left];</span><br><span class="line">            i ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SortUtil.less(aux[i - left], aux[j - left])) &#123;</span><br><span class="line">            arr[k] = aux[i - left];</span><br><span class="line">            i ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = aux[j - left];</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上述 merge 函数的归并过程</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%BD%92%E5%B9%B6%E8%BF%87%E7%A8%8B.png" alt></p>
<ol start="4">
<li><strong>自顶向下的归并排序</strong>，代码实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义一个全局的辅助数组，减少不必要的创建对象的开销</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[length];</span><br><span class="line">        mergeHelper(arr, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归使用归并排序，对 arr[left,right] 的元素进行归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeHelper</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//        if (left &gt;= right) &#123;</span></span><br><span class="line">    <span class="comment">//            return;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 考虑到在数组元素较少时，数组的有序程度会更高，采用插入排序能提高性能</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            Insertion.sort(arr, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeHelper(arr, left, mid);</span><br><span class="line">        mergeHelper(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 优化思路：当中间的数小于后面第一个数时，就不需要 merge</span></span><br><span class="line">        <span class="keyword">if</span> (!SortUtil.less(arr[mid], arr[mid + <span class="number">1</span>]))</span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优化思路一：</strong>第15行替换第11行，对小规模的子数组使用插入排序能提高效率；使用插入排序处理小规模子数组（如<strong>长度小于15</strong>）一般可以将归并排序的运行时间缩短 10%~15%</li>
<li><strong>优化思路二：</strong>添加第23行<strong>测试数组是否已经有序</strong>，如果 <strong>arr[mid] &lt;= arr[mid + 1]，我们可以认为数组已经是有序的了</strong>，那么就可以跳过 merge 方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间就变为线性了。</li>
</ul>
<ol start="5">
<li><strong>自底向上的归并排序</strong>：先两两归并，再四四归并，八八归并，，，从小问题解决直到解决大问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBU</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 进行 lgN 次两两归并</span></span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>;sz &lt;= N;sz = sz + sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>;left &lt; N - sz; left += sz + sz) &#123;</span><br><span class="line">        	Merge.merge(arr, left, left + sz - <span class="number">1</span>, Math.min(left + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>自顶向下与自底向上比较：</li>
</ol>
<ul>
<li><p>自底向上效率稍微低一些</p>
</li>
<li><h6 id="因为自底向上没有涉及数组某个位置元素的获取，比较适合-链表-组织的数据。这种方法只需要重新组织链表链接就能将链表原地排序（不需要创建任何新的链表节点）。"><a href="#因为自底向上没有涉及数组某个位置元素的获取，比较适合-链表-组织的数据。这种方法只需要重新组织链表链接就能将链表原地排序（不需要创建任何新的链表节点）。" class="headerlink" title="因为自底向上没有涉及数组某个位置元素的获取，比较适合==链表==组织的数据。这种方法只需要重新组织链表链接就能将链表原地排序（不需要创建任何新的链表节点）。"></a><strong>因为自底向上没有涉及数组某个位置元素的获取，比较适合==链表==组织的数据。这种方法只需要重新组织链表链接就能将链表原地排序（不需要创建任何新的链表节点）。</strong></h6></li>
</ul>
<h4 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h4><ol>
<li><strong>思想：</strong>分治。将一个数组分成两个子数组，将两部分独立地排序。</li>
<li>快排与归并排序是互补的：<ul>
<li>归并排序将数组分成两个子数组分别排序，并将有序子数组归并以将整个数组排序；快排将数组排序的方法是当两个子数组都有序时整个数组也就自然有序了。</li>
<li>快排，递归发生在处理整个数组之后；归并，递归发生在处理整个数组之前。</li>
<li><strong>归并排序，数组被等分成两半；快排，切分的位置取决于数组的内容。</strong></li>
</ul>
</li>
<li>快排实现代码（基础实现）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 对 arr[left, right] 的数组进行快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到标定元素所在的位置，快排的切分。</span></span><br><span class="line">        <span class="keyword">int</span> p = partition(arr, left, right);</span><br><span class="line">        sort(arr, left, p - <span class="number">1</span>);</span><br><span class="line">        sort(arr, p + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>切分示意图，代码如下</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%8F%8C%E8%B7%AF%E5%BF%AB%E6%8E%92.jpg" alt="双路快排切分示意图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 arr[left,right] 进行 partition</span></span><br><span class="line"><span class="comment">// 返回 j,使得 arr[l,j - 1] &lt;= arr[j],arr[j + 1,r] &gt;= arr[j]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// 能够解决数组中存在大量重复元素带来的，时间复杂度退化的问题</span></span><br><span class="line">    <span class="comment">// 每次随机选择一个数作为切分元素，避免顺序数组近乎有序时，快速排序退化为 o(n^2) 的问题</span></span><br><span class="line">    <span class="comment">// 不是完全解决，但是退化为 O(n^2) 的概率大大减小，几乎为0</span></span><br><span class="line">    SortUtil.swap(arr, left, random.nextInt(right + <span class="number">1</span>) % (right - left + <span class="number">1</span>) + left);</span><br><span class="line">    Comparable v = arr[left];</span><br><span class="line">    <span class="comment">// arr[left + 1, i) &lt;= v; arr(j,right] &gt;= v</span></span><br><span class="line">    <span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right &amp;&amp; SortUtil.less(arr[i], v)) i ++;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left &amp;&amp; !SortUtil.less(arr[j], v)) j --;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>; <span class="comment">// 死循环终止的条件</span></span><br><span class="line">        SortUtil.swap(arr, i, j);</span><br><span class="line">        i ++;</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    SortUtil.swap(arr, left, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>算法改进</p>
<ol>
<li><strong>小数组切换到插入排序：</strong>对于小数组，快排比插入排序慢；因为递归，快排的sort() 方法正在小数组中也会调用自己。修改如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的sort第7行</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">    Insertion.sort(arr, left, right);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>三路快排，见下一小节</li>
</ol>
</li>
<li><p><strong>三路快排</strong></p>
</li>
</ol>
<ul>
<li>三向切分示意图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%922.jpg" alt="三路快排"></p>
<ul>
<li>分析：<ul>
<li>arr[i]&lt;v，则 i 和 lt + 1 交换位置；lt ++, i ++</li>
<li>arr[i]&gt;v，则 i 和 gt - 1 交换位置；gt –, 因为是从左到右扫描，这个时候换过来的 gt - 1还没有扫描过，所以 i 不进行 + 1 操作</li>
<li>arr[i]=v，直接 i ++</li>
</ul>
</li>
<li>代码实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort3Ways</span><span class="params">(Comparable[] arr)</span> </span>&#123;</span><br><span class="line">    sort3Ways(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort3Ways</span><span class="params">(Comparable[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">        Insertion.sort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    SortUtil.swap(arr, left, random.nextInt(right + <span class="number">1</span>) % (right - left + <span class="number">1</span>) + left);</span><br><span class="line">    Comparable v = arr[left];</span><br><span class="line">    <span class="keyword">int</span> lt = left;  <span class="comment">// arr[left + 1, lt] &lt; v,确保初始化时，没有满足条件的元素</span></span><br><span class="line">    <span class="keyword">int</span> gt = right + <span class="number">1</span>; <span class="comment">// arr[gt, right] &gt; v,确保初始化时，没有满足条件的元素</span></span><br><span class="line">    <span class="keyword">int</span> i = left + <span class="number">1</span>;   <span class="comment">// arr[lt + 1, i) = v</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SortUtil.less(arr[i], v)) &#123;</span><br><span class="line">            SortUtil.swap(arr, i, lt + <span class="number">1</span>);</span><br><span class="line">            lt ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!SortUtil.less(arr[i], v)) &#123;</span><br><span class="line">            SortUtil.swap(arr, i, gt - <span class="number">1</span>);</span><br><span class="line">            gt --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SortUtil.swap(arr, left, lt);</span><br><span class="line">    sort3Ways(arr, left, lt - <span class="number">1</span>);</span><br><span class="line">    sort3Ways(arr, gt, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM - 虚拟机类加载机制</title>
    <url>/2019/09/30/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote>
<p>虚拟机把描述类的数据从 Class 文件中加载到内存，并对数据进行<strong>校验、转换解析和初始化</strong>，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
</blockquote>
<ol>
<li>以下描述的 “Class文件” 指的是一串二进制字节流，无论以任何形式存在都可以。</li>
</ol>
<hr>
<a id="more"></a>

<h3 id="2-类加载的时机"><a href="#2-类加载的时机" class="headerlink" title="2. 类加载的时机"></a>2. 类加载的时机</h3><ol>
<li>从加载到卸载出内存，生命周期包括：<strong>加载（Loading）、验证（Verification）、准备（Preparing）、解析（Resolution）、初始化（Initialization）、使用、卸载（Unloading)。</strong>其中，验证、准备和解析统称为<strong>连接（Linking）。</strong>类的生命周期如下图所示：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F1.jpg" alt="类的生命周期"></p>
<ol start="2">
<li>加载、验证、准备、初始化和卸载的顺序都是固定的，解析过程在某些情况下可以在初始化过程之后再开始，为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）。</li>
<li>什么情况下需要开始类的加载，在虚拟机规范中并没有明确指出，交由虚拟机的具体实现来自由把握。<strong>但对于初始化阶段，虚拟机规范中严格规定了</strong> <strong><em>有且只有</em></strong>  <strong>5中情况必须立即对类进行“初始化”，当然，加载，验证和准备在这之前就肯定已经完成了。</strong></li>
</ol>
<ul>
<li>遇到 <strong>new, getstatic, putstatic, invokestatic</strong> 这4条字节码指令时，如果类没有初始化，则需要先触发其初始化。<strong>使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态变量除外）、以及调用一个类的静态方法的时候</strong>会生成这4条指令。</li>
<li>使用 java.lang.reflect 的方法对类进行反射调用的时候。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，需要先出发父类的初始化。</li>
<li>当虚拟机启动时，用户需要先指定一个要执行的类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 1.7 的动态语言支持时；</li>
</ul>
<ol start="4">
<li>上述5中场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为<strong>“被动引用”</strong>。</li>
<li><strong>被动引用</strong>的例子<ol>
<li><strong>通过子类引用父类的静态字段，不会导致子类初始化；</strong></li>
<li><strong>通过数组定义来引用类，不会触发此类的初始化；</strong></li>
<li><strong>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</strong></li>
</ol>
</li>
<li>接口与类初始化的区别：<ul>
<li><strong>当一个类初始化的时候，要求他的父类一定已经初始化过，但对接口而言，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</strong></li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-类加载的过程"><a href="#3-类加载的过程" class="headerlink" title="3. 类加载的过程"></a>3. 类加载的过程</h3><h4 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h4><ol>
<li>在加载阶段，虚拟机需要完成三件事情：<ol>
<li><strong>通过一个类的全限定名来获取此类的二进制字节流；</strong></li>
<li><strong>将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构；</strong></li>
<li><strong>在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</strong></li>
</ol>
</li>
<li>开发人员可以通过<strong>自定义的类加载器</strong>去控制字节流的获取方式（即重写一个类加载器的 loadClass() 方法）。</li>
<li>数组类本身不通过类加载器创建，但数组的元素类型要考类加载器创建。</li>
<li>加载与连接阶段的部分内容是交叉进行的，但阶段的开始顺序保持固定。</li>
<li><strong>“加载”是“类加载”过程的一部分。</strong></li>
</ol>
<h4 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h4><blockquote>
<p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
</blockquote>
<ul>
<li>分为四个阶段的检验<ul>
<li><strong>文件格式验证：</strong>验证<strong>字节流</strong>是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机理解。只有通过该阶段的验证后，字节流才会进入内存的方法区中进行存储。</li>
<li><strong>元数据验证：</strong>对<strong>字节码描述的信息</strong>进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</li>
<li><strong>字节码验证：</strong>最复杂，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</li>
<li><strong>符号引用验证：</strong>在<strong>解析阶段发生</strong>，为了确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个 java.lang.IncompatibleClassChangeError 异常的子类。</li>
</ul>
</li>
<li>验证阶段<strong>重要但不一定必要</strong>（因为对程序运行期没有影响）。</li>
<li>若所运行的代码已经被反复使用和验证过，那么在实施阶段就可以考虑使用 -Xverify：none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li>
</ul>
<h4 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h4><blockquote>
<p>准备阶段是正式为<strong>类变量分配内存</strong>并设置<strong>类变量初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<ul>
<li>内存分配的仅仅是类变量（静态的，被 static 修饰的变量），不包含实例变量。</li>
<li>初始值“通常情况”下指的是<strong>数据类型的零值</strong>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&gt; <span class="comment">// value 在准备阶段过后的初始值为0，而不是123，因为这个时候尚未执行任何 java 方法，而把 value // 赋值为 123 的 putstatic 命令是程序被编译后，存放于类构造器&lt;clinit&gt;()方法之中，所以把value // 赋值为123的动作将在 初始化阶段 才会执行。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>基本数据类型的零值表：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">零值</th>
<th align="center">数据类型</th>
<th align="center">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘\u0000’</td>
<td align="center">reference</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ol start="2">
<li>如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 Constantvalue 属性所指的值。（被 final 修饰的字段）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为123</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h4><blockquote>
<p>解析阶段是虚拟机将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。</p>
</blockquote>
<ol>
<li><strong>符号引用：</strong>用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可；</li>
<li><strong>直接引用：</strong>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那么引用的目标必定已经存在于内存中。</li>
<li>虚拟机实现可以<strong>对第一次解析的结果进行缓存</strong>（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而<strong>避免解析动作重复进行</strong>。</li>
<li><strong>类或接口的解析</strong></li>
<li><strong>字段的解析</strong></li>
<li><strong>类方法解析</strong></li>
<li><strong>接口方法解析</strong></li>
</ol>
<h4 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h4><blockquote>
<p>到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）</p>
</blockquote>
<hr>
<h3 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4. 类加载器"></a>4. 类加载器</h3><h4 id="4-1-类与类加载器"><a href="#4-1-类与类加载器" class="headerlink" title="4.1 类与类加载器"></a>4.1 类与类加载器</h4><ol>
<li><strong>对任意一个类，都需要由加载他的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名空间。</strong> </li>
<li>——等同于——&gt; <strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，这两个类就必定不相等。</strong></li>
</ol>
<h4 id="4-2-双亲委派模型"><a href="#4-2-双亲委派模型" class="headerlink" title="4.2 双亲委派模型"></a>4.2 双亲委派模型</h4><ol>
<li>从 Java 虚拟机角度而言，只存在两种类加载器：<ol>
<li><strong>启动类加载器（Bootstrap ClassLoader)：</strong>使用 C++ 实现。是虚拟机自身的一部分。</li>
<li><strong>其他类加载器：</strong>由 Java 语言实现，独立于虚拟机外部，且全都继承自抽象类 java.lang.ClassLoader</li>
</ol>
</li>
<li>程序员角度：<ol>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用程序类加载器或系统类加载器</li>
</ol>
</li>
<li><strong>类加载器双亲委派模型</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="双亲委派模型"></p>
<ol start="4">
<li>双亲委派的过程：<ol>
<li><strong>来加载器收到类加载的请求，自己不去尝试加载；</strong></li>
<li><strong>将请求委派给父类加载器去完成</strong></li>
<li><strong>每一个层次的类加载器都如此</strong></li>
<li><strong>所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</strong></li>
</ol>
</li>
<li>好处：<ol>
<li>Java 类随着他的类加载器一起具备了一种带有优先级的层次关系。</li>
<li>保证 Java 程序的稳定运作</li>
</ol>
</li>
</ol>
<h4 id="4-3-破坏双亲委派模型"><a href="#4-3-破坏双亲委派模型" class="headerlink" title="4.3 破坏双亲委派模型"></a>4.3 破坏双亲委派模型</h4><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><blockquote>
<p>介绍了类加载过程的“加载”，“验证”，“准备”，“解析”和“初始化”5个阶段虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。</p>
</blockquote>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-垃圾收集器与内存分配策略</title>
    <url>/2019/09/27/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<blockquote>
<p>垃圾回收（Garbage Collection）需要解决的三个问题：</p>
<ol>
<li><strong>哪些内存需要回收</strong></li>
<li><strong>什么时候回收</strong></li>
<li><strong>怎么回收</strong></li>
</ol>
</blockquote>
<a id="more"></a>

<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ol>
<li>当需要排查各种内存泄漏、溢出问题时，当垃圾回收集成为系统达到更高并发量的瓶颈时，就需要对“自动化”的技术实施必要的监控和调节。</li>
<li>程序计数器、虚拟机栈、本地方法栈都随线程而生死，即内存区域和回收都具有确定性</li>
<li>Java 回收针对的对象：<strong>Java 堆</strong>，这一部分内存只有在程序运行期间才能知道创建哪些对象，内存的分配和回收都是动态的。</li>
</ol>
<h3 id="2-判断对象已死？"><a href="#2-判断对象已死？" class="headerlink" title="2. 判断对象已死？"></a>2. 判断对象已死？</h3><p>不可能再被任何途径使用的对象称为：“死去”的对象</p>
<h4 id="2-1-引用计数法（Reference-Counting）"><a href="#2-1-引用计数法（Reference-Counting）" class="headerlink" title="2.1 引用计数法（Reference Counting）"></a>2.1 引用计数法（Reference Counting）</h4><blockquote>
<p>给对象中添加一个引用计数器，每当有一个地方引用该对象，计数器加1；当引用失效时，计数器减1；任何时候计数器值为0的对象就是不可能被再次使用的对象。</p>
</blockquote>
<ol>
<li>实现简单，判定效率高。</li>
<li>缺点：<ul>
<li><strong>很难解决对象之间相互循环引用的问题</strong>，所以主流 JVM 中没有使用该算法</li>
</ul>
</li>
</ol>
<h4 id="2-2-可达性分析算法（Reachability-Analysis）"><a href="#2-2-可达性分析算法（Reachability-Analysis）" class="headerlink" title="2.2 可达性分析算法（Reachability Analysis）"></a>2.2 可达性分析算法（Reachability Analysis）</h4><p>主流的如 Java、C#等语言的主流实现中都是通过可达性分析来判断对象是否存活。</p>
<blockquote>
<p>通过一系列的称为<strong>“GC Roots”</strong>的对象作为起始点，从这些节点往下搜索，搜索所走过的路径称之为<strong>“引用链（Reference Chain）”</strong>，当一个对象到<strong>“GC Roots”</strong>没有任何引用链相连时，则证明此对象是不可用的。</p>
</blockquote>
<p>可以作为<strong>“GC Roots”</strong>的对象：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI （Native 方法）引用的对象</li>
</ul>
<h4 id="2-3-引用"><a href="#2-3-引用" class="headerlink" title="2.3 引用"></a>2.3 引用</h4><blockquote>
<p><strong>强引用、软引用、弱引用、虚引用</strong></p>
</blockquote>
<ul>
<li><strong>强引用</strong></li>
</ul>
<p>在程序代码中普遍存在的，类似于“Object o = new Object() ”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<ul>
<li><strong>软引用</strong></li>
</ul>
<p>描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<ul>
<li><strong>弱引用</strong></li>
</ul>
<p>描述非必须的对象，强度低于软引用。被引用的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作的时候，无论当前内存是否足够，都会回收掉被弱引用关联的对象。</p>
<ul>
<li><strong>虚引用</strong></li>
</ul>
<p>幽灵引用或幻影引用，是最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过一个虚引用来取得一个对象的实例。设置虚引用关联的唯一目的是：<strong>能在这个对象被回收器回收的时候收到一个系统通知。 - PhantomReference类来实现虚引用</strong></p>
<h4 id="2-4-生存-OR-死亡"><a href="#2-4-生存-OR-死亡" class="headerlink" title="2.4 生存 OR 死亡"></a>2.4 生存 OR 死亡</h4><blockquote>
<p>真正宣告一个对象死亡，至少要经过两个标记过程：</p>
<ol>
<li>进行<strong>可达性分析</strong>后发现对象没有与<strong>“GC Roots”</strong>相连接的引用链，那他将被第一次标记并且进行第一筛选，筛选的条件是此对象是否有必要执行 <strong>finalize()</strong> 方法。当对象没有覆盖 <strong>finalize()</strong> 方法，或者 <strong>finalize()</strong> 方法<strong>已经被虚拟机调用过</strong>，虚拟机将这两种情况都视为“没有必要执行”。</li>
<li><strong>finalize()</strong>  方法是逃脱死亡的最后一次机会，只要对象在方法中重新与引用链上的任何一个对象建立关联即可。（把自己即 this 关键字赋值给类变量或者对象的成员变量）</li>
</ol>
</blockquote>
<ul>
<li><strong>任何对象的 finalize() 方法都只会被系统自动调用一次！</strong></li>
<li><strong>finalize()</strong> 方法运行代价高昂、不确定性大，无法保证每一个对象的调用顺序。</li>
<li><strong>finalize()</strong> 能做的所有工作，使用 <strong>try-finally</strong> 或其他方法都可以做的<strong>更好、更及时</strong>。</li>
</ul>
<h4 id="2-5-回收方法区"><a href="#2-5-回收方法区" class="headerlink" title="2.5 回收方法区"></a>2.5 回收方法区</h4><ul>
<li>“无用的类”：<ul>
<li>该类所有实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；</li>
<li>加载该类的 ClassLoader 已经被回收；</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h3><h4 id="3-1-标记-清除算法（Mark-Sweep）"><a href="#3-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="3.1 标记 - 清除算法（Mark - Sweep）"></a>3.1 标记 - 清除算法（Mark - Sweep）</h4><ul>
<li><strong>定义：首先标记出所有需要回收的对象，在标记完成后统一回收没有被标记的对象</strong>。是后续收集算法的基础。</li>
<li>缺点：<ul>
<li><strong>效率问题：</strong>标记和清除的效率都不高；因为内存碎片存在，操作会变得更加耗时，因为查找一块可用空闲的内存已经不是一个简单的操作。</li>
<li><strong>空间问题：</strong>标记清除过后对产生大量的<strong>不连续内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95.png" alt="Mark - Sweep"></p>
<p><a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener">图源：深入理解JVM(2)——GC算法与内存分配策略</a></p>
<h4 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h4><ul>
<li>为解决上述算法的效率问题；</li>
<li>将可用内存<strong>按容量划分为大小相等的两块</strong>，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象<strong>复制</strong>到另外一块上面，<strong>然后再把已使用的内存空间一次清理掉</strong>。这样使得每次都是对<strong>整个半区进行内存回收</strong>，内存分配时就<strong>不用考虑内存碎片</strong>等复杂情况，只要<strong>移动堆顶指针，按顺序分配内存</strong>即可，实现简单，运行高效；</li>
<li>代价：将内存缩小为原来的一般，代价太高。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%A4%8D%E5%88%B6%E6%B3%95.png" alt="Copying"></p>
<p><a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener">图源：深入理解JVM(2)——GC算法与内存分配策略</a></p>
<blockquote>
<p>商业虚拟机并不是按 1：1来分配内存空间。也用复制算法。</p>
</blockquote>
<p><strong>“Minor GC”：</strong>将内存划分为<strong>一块较大的 Eden 空间和两块较小的 Survivor 空间</strong>，每次使用 Eden 和其中一块 Survivor 。回收时，将 Eden 和 Survivor 中还存活的对象<strong>一次性复制到</strong> 另外一个 Survivor 空间上，最后清理掉 Eden 和用过的 Survivor 空间。</p>
<p>HotSpot 虚拟机默认 <strong>Eden ： Survivor = 8 ：1</strong>；也就是每次新生代中<strong>可用内存空间为整个新生代容量的 90 %</strong>，只有 10 % 被浪费。当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保（Handle Promotion）。</strong></p>
<p><strong>分配担保：</strong>如果另外一块 Survivor 空间不足以存放上一次新生代收集下来的存活对象时这些对象直接通过分配担保机制进入老年代。</p>
<h4 id="3-3-标记-整理算法（Mark-Compact）"><a href="#3-3-标记-整理算法（Mark-Compact）" class="headerlink" title="3.3 标记 - 整理算法（Mark - Compact）"></a>3.3 标记 - 整理算法（Mark - Compact）</h4><ul>
<li>复制收集算法在对象存活率较高时就需要进行较多的复制操作，效率会变低。为应对被使用的内存中所有对象都是100%存活的极端情况，在老年代一般不直接选用复制算法。</li>
</ul>
<p><strong>标记 - 整理算法：</strong>标记过程与“标记-清除”一样，后续步骤不是直接对可回收对象进行清理，而是让<strong>所有存活对象都像一端移动</strong>，然后<strong>直接清理掉端边界以外</strong>的内存。</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86.png" alt="Mark - Sweep"></p>
<p><a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener">图源：深入理解JVM(2)——GC算法与内存分配策略</a></p>
<h4 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h4><blockquote>
<p>当代商业虚拟机的垃圾回收采用该算法。<strong>Generation Collection</strong></p>
</blockquote>
<ul>
<li><strong>新生代：</strong>每次垃圾收集时都有大批对象死去，选用<strong>复制算法</strong>，只需要少量存活对象的复制成本就可以完成收集；</li>
<li><strong>老年代：</strong>对象存活率高、没有额外空间对他进行分配担保，就使用<strong>“标记 - 清理” 或 “标记 - 整理”</strong>。</li>
</ul>
<hr>
<h3 id="4-HotSpot-的算法实现"><a href="#4-HotSpot-的算法实现" class="headerlink" title="4. HotSpot 的算法实现"></a>4. HotSpot 的算法实现</h3><p>在执行上述垃圾回收算法的时候，必须对算法的执行效率进行严格的考量，才能保证虚拟机高效运行。</p>
<h4 id="4-1-枚举根节点"><a href="#4-1-枚举根节点" class="headerlink" title="4.1 枚举根节点"></a>4.1 枚举根节点</h4><ol>
<li>方法区很大，如果要逐个检查这里面的引用，必然会消耗很多的时间。</li>
<li>可达性分析<strong>对执行时间的敏感还体现在 GC 停顿上</strong>，因为这项工作必须在一个能保证一致性的快照中进行——这里的“一致性”指的是在整个分析期间整个执行系统看起来<strong>就像被冻结在某个时间点</strong>上，不可以出现分析过程中对象引用关系还在不断的变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致 GC 进行时停止所有 Java 线程<strong>（Stop The World）</strong>的原因。</li>
</ol>
<h4 id="4-2-安全点"><a href="#4-2-安全点" class="headerlink" title="4.2 安全点"></a>4.2 安全点</h4><ol>
<li>在 OopMap 的协助下，HotSpot 可以快速准确地完成 GC Roots 枚举，但可能会导致引用关系变化。</li>
<li>Hotspot 没有为每条指令生成 OopMap，只在“特定的位置”记录了这些信息，这些位置称为安全点<strong>（SafePoint）</strong>。即程序执行并非在所有的地方都停顿下来开始 GC，只有在达到安全点时才能暂停。</li>
<li>安全点不能太多，也不能太少。<ul>
<li><strong>太多：</strong>过分增大运行时负载；</li>
<li><strong>太少：</strong>让 GC 等待时间太长</li>
</ul>
</li>
<li>安全点的选择：<ol>
<li>以程序<strong>“是否具备让程序长时间执行的特征”</strong>；</li>
<li><strong>方法调用、循环跳转、异常跳转</strong>等产生 <strong>SafePoint</strong></li>
</ol>
</li>
<li>如何在 GC 发生时让所有线程到最近的安全点再停顿：<ol>
<li><strong>抢先式中断</strong>（现在几乎没有虚拟机采用这种方式来暂停线程从而响应 GC 事件）</li>
<li><strong>主动式中断</strong><ul>
<li>当 GC 需要中断线程时，不直接对线程操作，仅仅简单的设置一个标志，各线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="4-3-安全区域"><a href="#4-3-安全区域" class="headerlink" title="4.3 安全区域"></a>4.3 安全区域</h4><blockquote>
<p>指的是在一段代码区域中，引用关系不会发生变化。在这个区域的任意位置 开始 GC 都是安全的。</p>
</blockquote>
<hr>
<h3 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h3><p>垃圾收集器的实现由厂商自己实现，下面讨论的垃圾收集器是基于 JDK 1.7 Update 14之后的 Hotspot 虚拟机。</p>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt></p>
<p>​                                                                图：HotSpot 虚拟机的垃圾收集器</p>
<p>存在连线说明两两可以相互搭配使用。重点分析 <strong>CMS 和 G1</strong></p>
<p>目前不存在最好的垃圾收集器，只存在在各种场景下最合适的垃圾收集器。</p>
<h4 id="5-0-相关概念"><a href="#5-0-相关概念" class="headerlink" title="5.0 相关概念"></a>5.0 相关概念</h4><ul>
<li><strong>并行（Parallel）：</strong>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）：</strong>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行。而垃圾收集程序运行在另外一个 CPU 上。</li>
<li><strong>吞吐量（Throughput）：</strong> <strong>吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）</strong></li>
</ul>
<h4 id="5-1-Serial-收集器"><a href="#5-1-Serial-收集器" class="headerlink" title="5.1 Serial 收集器"></a>5.1 Serial 收集器</h4><ol>
<li>最基本、历史最悠久，新生代收集器。</li>
<li><strong>单线程收集器：</strong>不仅仅说明他只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，重要的是在他进行垃圾收集时，必须暂停其他所有的线程直到收集结束。</li>
<li>收集运行示意图如下：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/Serial.png" alt="Serial"></p>
<p><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">本节图源：深入理解JVM(3)</a></p>
<ol start="4">
<li>虚拟机运行在 Client 模式下的默认新生代收集器。</li>
<li>优点：<strong>简单高效</strong>（相比其他收集器而言），对于限定单个 CPU 的环境来说， Serial 收集器由于<strong>没有线程交互</strong>的开销，专心做垃圾收集可以获得最高的单线程收集效率。</li>
</ol>
<h4 id="5-2-ParNew-收集器"><a href="#5-2-ParNew-收集器" class="headerlink" title="5.2 ParNew 收集器"></a>5.2 ParNew 收集器</h4><ol>
<li>Serial 的多线程版本，除了多条线程，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同。</li>
<li>收集器运行示意图：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/ParNew.png" alt="ParNew"></p>
<ol start="3">
<li>在 Server 模式下虚拟机的首选新生代收集器，<strong>除 Serial 外，她是唯一一个可以与 CMS 配合的收集器。</strong></li>
<li>在 CPU 非常多的情况下，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。</li>
</ol>
<h4 id="5-3-Parallel-Scavenge-收集器"><a href="#5-3-Parallel-Scavenge-收集器" class="headerlink" title="5.3 Parallel Scavenge 收集器"></a>5.3 Parallel Scavenge 收集器</h4><ol>
<li>使用<strong>复制算法</strong>的<strong>新生代</strong>多线程收集器。</li>
<li>目的：达到一个可控制的吞吐量，关注点就在吞吐量，<strong>“吞吐量优先收集器”。</strong></li>
<li><strong>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</strong></li>
<li>在手工优化存在困难的时候，使用 Parallel Scavenge 配合<strong>自适应的调节策略</strong>，把内存管理的工作交给虚拟机去完成。 </li>
</ol>
<h4 id="5-4-Serial-Old-收集器"><a href="#5-4-Serial-Old-收集器" class="headerlink" title="5.4 Serial Old 收集器"></a>5.4 Serial Old 收集器</h4><ol>
<li>Serial 的老年代版本；</li>
<li>使用 <strong>“标记 - 整理”</strong> 算法；</li>
<li>用途：<ol>
<li>在 JDK 1.5 之前与 Parallel Scavenge 搭配使用；</li>
<li><strong>作为 CMS 的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</strong></li>
</ol>
</li>
<li>运行示意图同 Serial。</li>
</ol>
<h4 id="5-5-Parallel-Old-收集器"><a href="#5-5-Parallel-Old-收集器" class="headerlink" title="5.5 Parallel Old 收集器"></a>5.5 Parallel Old 收集器</h4><ol>
<li>Parallel 的老年代版本；</li>
<li>使用 <strong>“标记 - 整理”</strong> 算法；</li>
<li><strong>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</strong></li>
<li>运行示意图同 Parallel Scavenge。</li>
</ol>
<h4 id="5-6-CMS-收集器"><a href="#5-6-CMS-收集器" class="headerlink" title="5.6 CMS 收集器"></a>5.6 CMS 收集器</h4><ol>
<li><strong>CMS（Concurrent Mark Sweep）</strong>是一种以<strong>获取最短回收停顿时间为目标</strong>的收集器。</li>
<li>该算法的<strong>“标记 - 清除”</strong>步骤：<ul>
<li><strong>初始标记（Initial Mark）：</strong>仅仅只是标记一下 GC Roots 能关联到的对象，速度很快。</li>
<li><strong>并发标记（Concurrent Mark）：</strong>进行 <strong>GC Roots Tracing</strong> 的过程，在整个过程中耗时最长。</li>
<li><strong>重新标记（Remark）：</strong>为修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般比初试标记阶段稍长，远比并发标记时间短。</li>
<li><strong>并发清除（Concurrent Sweep）</strong></li>
</ul>
</li>
</ol>
<p>其中，<strong>初始标记</strong>和<strong>重新标记</strong>需要 <strong>“Stop The World”</strong>。</p>
<ol start="3">
<li>运行示意图如下：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/CMS.png" alt="CMS"></p>
<ol start="4">
<li><strong>优点：</strong><ul>
<li><strong>并发收集；</strong></li>
<li><strong>低停顿。</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>CMS 收集器对 CPU 资源敏感；</li>
<li>CMS 收集器无法处理浮动垃圾（Floating Garbage），可能出现 “Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。</li>
<li>CMS 基于“标记 - 清除” 算法，<strong>导致空间碎片太多</strong>，会给大对象分配带来麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，<strong>不得不提前触发一次 Full GC。</strong></li>
</ul>
</li>
</ol>
<h4 id="5-7-G1-收集器"><a href="#5-7-G1-收集器" class="headerlink" title="5.7 G1 收集器"></a>5.7 G1 收集器</h4><ol>
<li><strong>面向服务端应用的垃圾收集器。目标是在未来替换掉 JDK 1.5 中发布的 CMS 收集器。</strong></li>
<li>具有的特点：<ul>
<li><strong>并行与并发：</strong>充分利用多 CPU、多核环境下的硬件优势，缩短 “Stop The World” 的时间，可以通过并发的方式让 Java 程序继续执行；</li>
<li><strong>分代收集：</strong></li>
<li><strong>空间整合：</strong>运作期间不会产生大量的空间碎片，收集后能提供规整的内存空间，有利于程序长时间运行。</li>
<li><strong>可预测的停顿：</strong>能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，这几乎已经是 Java （RTSJ） 的垃圾收集器的特征了。</li>
</ul>
</li>
<li>使用 G1收集器时，Java 堆的内存布局不同于其他，它将整个 Java 堆划分为多个大小相等的区域，保留了新生代和老年代，但不再是物理隔离的，都是一部分区域的集合。</li>
<li>这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>G1 收集器的运作：<ol>
<li><strong>初始标记（Initial Marking)</strong></li>
<li><strong>并发标记（Concurrent Marking）:</strong>从 GC Roots 开始对堆中对象进行可达性分析，需要停顿线程，但耗时很短。可与用户程序并发进行。</li>
<li><strong>最终标记（Final Marking）</strong></li>
<li><strong>筛选回收（Live Data counting and Evacuation)：</strong>首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ol>
</li>
<li>运行示意图：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/G1.png" alt="G1"></p>
<h4 id="5-8-内存分配与回收策略"><a href="#5-8-内存分配与回收策略" class="headerlink" title="5.8 内存分配与回收策略"></a>5.8 内存分配与回收策略</h4><ol>
<li>对象优先在 Eden 分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将进入老年代</li>
<li>动态对象年龄判断</li>
<li>空间分配担保</li>
</ol>
<h4 id="5-9-总结"><a href="#5-9-总结" class="headerlink" title="5.9 总结"></a>5.9 总结</h4><table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行、并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Server模式、与CMS配合</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任何</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任何</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td><strong>并发</strong></td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td><strong>并发</strong></td>
<td>都</td>
<td><strong>标记-整理+   复制算法</strong></td>
<td>响应速度优先</td>
<td>将来替换CMS</td>
</tr>
</tbody></table>
<h3 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h3><ul>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">深入理解Java虚拟机（第2版）- 周志明</a></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-内存区域与内存溢出异常</title>
    <url>/2019/09/27/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>参考：周志明 - 《深入立即 Java 虚拟机》- Chapter 2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>Java 程序员将内存控制的权利交给虚拟机，当虚拟机出现内存泄漏和溢出方面的问题，排除错误需要深入理解 Java 虚拟机是如何使用内存的。</p>
<h3 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2. 运行时数据区域"></a>2. 运行时数据区域</h3><blockquote>
<p>Java 虚拟机在运行程序的时候会把他所管理的内存划分为若干个不同的数据区域。有的区域随着虚拟机进程的启动而存在，有的依赖于用户线程的启动和结束而建立和销毁</p>
</blockquote>
<ul>
<li><strong>所有线程共享的数据区</strong><ul>
<li>方法区 - Method Area</li>
<li>堆 - Heap</li>
</ul>
</li>
<li><strong>线程隔离区域</strong>（线程私有）<ul>
<li>虚拟机栈 - VM Stack</li>
<li>本地方法栈 - Native Method Stack</li>
<li>程序计数器 - Program Counter Register</li>
</ul>
</li>
</ul>
<h4 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h4><blockquote>
<p>是一块<strong>较小</strong>的内存空间，可以看成是当前线程所执行的字节码的<strong>行号指示器</strong>。</p>
</blockquote>
<p>在任何时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程的程序计数器互不影响，独立存储，这样的内存区域称为“线程私有”的内存。</p>
<ol>
<li>线程执行 Java 方法：程序计数器记录的是正在执行的虚拟机字节码指令的地址；</li>
<li>线程执行 Native 方法：值为空（Undefined）；</li>
<li>该内存区域是 Java 虚拟机规范中唯一一个没有规定任何 OutOfMemoryError 的区域。</li>
</ol>
<h4 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h4><blockquote>
<p>描述的是 Java 方法执行的内存模型：<strong>每个方法在执行的同时</strong>都会创建一个<strong>栈帧（Stack Frame）</strong>用来存储<strong>局部变量表</strong>、<strong>操作数帧</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。</p>
</blockquote>
<ol>
<li>局部变量表：存放编译器可知的8中基本数据类型、引用类型和 returnAddress类型（指向了一条字节码指令的地址）；</li>
<li>64位长度的 long 和 double 占用两个局部变量空间，其余数据类型占用一个；</li>
<li>局部变量表所需的内存空间在编译期完成分配，方法运行期间，局部变量表不变。</li>
</ol>
<ul>
<li><strong>该区域有两种异常状况：</strong><ul>
<li>线程请求的<strong>栈深度</strong>大于虚拟机所允许的深度，抛出 <strong>StackOverflowError</strong> 异常；</li>
<li>若<strong>动态扩展</strong>时无法申请到足够的内存，抛出 <strong>OutOfMemoryError</strong> 异常。</li>
</ul>
</li>
</ul>
<h4 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h4><blockquote>
<p>虚拟机栈：为虚拟机执行 Java 方法服务</p>
<p>本地方法栈：为虚拟机使用的 Native 方法服务</p>
</blockquote>
<p>异常情况同虚拟机栈。</p>
<h4 id="2-4-Java-堆"><a href="#2-4-Java-堆" class="headerlink" title="2.4 Java 堆"></a>2.4 Java 堆</h4><ol>
<li>是虚拟机管理的内存中<strong>最大</strong>的一块</li>
<li><strong>存在的唯一目的：存放对象实例，<em>几乎所有的对象</em> 实例都在这里分配内存。</strong></li>
<li><strong>是垃圾收集管理的主要区域。</strong>- GC堆</li>
<li>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 <strong>OutOfMemoryError</strong> </li>
</ol>
<h4 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h4><blockquote>
<p>用于存储已被虚拟机加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据。</p>
</blockquote>
<p>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名 - “非堆（Non-Heap）”</p>
<ol>
<li>当方法区无法满足内存分配需求时，抛出 <strong>OutOfMemoryError</strong> 异常</li>
</ol>
<h4 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h4><blockquote>
<p>是方法区的一部分。</p>
<p>Class 文件有<strong>类的版本、字段、方法、接口</strong>等描述信息，还有一个<strong>常量池</strong>信息，用于存放编译期生成的各种字面量和符号引用。</p>
</blockquote>
<ol>
<li>运行时常量池相较于 Class 文件常量池的特征：<strong>具备动态性</strong></li>
</ol>
<h4 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h4><blockquote>
<p>不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但也可能导致 OutOfMemoryError 异常。</p>
</blockquote>
<h3 id="3-HotSpot虚拟机对象"><a href="#3-HotSpot虚拟机对象" class="headerlink" title="3. HotSpot虚拟机对象"></a>3. HotSpot虚拟机对象</h3><p>以下讨论基于 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h4 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h4><ol>
<li>虚拟机遇到一条 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先要执行相应的类加载过程。</li>
<li>类加载检查通过后，为新生对象分配内存。两种内存分配方式：</li>
</ol>
<ul>
<li><strong>指针碰撞（Bump the Pointer）</strong></li>
</ul>
<p>假设 Java 堆中内存是绝对规整的，所有用过的内存放在一边，没有用过的（空闲的）放在另外一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
<ul>
<li><strong>空闲列表（Free List）</strong></li>
</ul>
<p>Java 内存中的内存不是规整的，使用过的和空闲的相互交错，指针碰撞失效。则虚拟机需要维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表记录。</p>
<ul>
<li>如何选择？<ul>
<li>由 Java 堆是否规整决定，Java 堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定；</li>
<li>Serial、ParNew 等带 Compact 过程的收集器：<strong>指针碰撞</strong></li>
<li>CMS 等基于 Mark - Sweep 算法的收集器：<strong>空闲列表</strong></li>
</ul>
</li>
<li>解决并发情况下的线程安全问题：<ul>
<li>对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的<strong>原子性</strong>。</li>
<li>把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在 Java 堆中预先分配一小块内存，称之为<strong>本地线程分配缓冲（Thread Local Allocation Buffer - TLAB）</strong>。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB，可以通过 -XX：+UseTLAB 参数来设定。</li>
</ul>
</li>
</ul>
<h4 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h4><blockquote>
<p>对象在内存中的布局可以分为3块区域：<strong>对象头（Mark Word 和 类型指针）</strong>；<strong>实例数据（Instance Data）</strong>；<strong>对齐填充（Padding）</strong></p>
</blockquote>
<ol>
<li>对象头 -&gt; Mark Word</li>
</ol>
<blockquote>
<p>存储对象自身的运行时数据，如<strong>哈希表、GC分代年龄、锁标志状态、线程持有的锁、偏向线程ID、偏向时间戳</strong>等。非固定的数据结构。</p>
</blockquote>
<ul>
<li>在32位 HotSpot 虚拟机中，如果对象处于未锁定的状态下，那么 Mark Word 的32位中的25位用于存储对象哈希码，4位用于存储对象分代年龄，2位用于存储锁标志位，1位固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的储存内容见表：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">存储内容</th>
<th align="center">标志位</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">对象哈希码、对象分代年龄</td>
<td align="center">01</td>
<td align="center">未锁定</td>
</tr>
<tr>
<td align="center">指向锁记录的指针</td>
<td align="center">00</td>
<td align="center">轻量级锁定</td>
</tr>
<tr>
<td align="center">指向重量级锁的指针</td>
<td align="center">10</td>
<td align="center">膨胀（重量级锁定）</td>
</tr>
<tr>
<td align="center">空，不需要记录信息</td>
<td align="center">11</td>
<td align="center">GC标记</td>
</tr>
<tr>
<td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td>
<td align="center">01</td>
<td align="center">可偏向</td>
</tr>
</tbody></table>
<ul>
<li>类型指针：即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<ol start="2">
<li>对齐填充</li>
</ol>
<p>不是必然存在的，也没有特别的含义，仅起着占位符的作用。对象头部分正好是8字节的整数倍，所以当对象实例数据部分没有对齐的时候，就需要通过对齐填充来补全。</p>
<h4 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h4><blockquote>
<p>对象访问方式取决于虚拟机实现。主流访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong></p>
</blockquote>
<ol>
<li>使用句柄访问的最大优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾搜集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要改变</li>
<li>使用直接指针：速度更快，节省了一次指针定位的时间开销</li>
</ol>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础</title>
    <url>/2019/09/21/Java-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>总结不太会的 Java 基础知识点。</p>
<a id="more"></a>

<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><ol>
<li>JVM 会在编译时期将 boolean 类型的数据转换为 int。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的；</li>
<li>自动装箱调用了 Integer.valueOf(基本类型)：将给定的基本类型转换成对应的包装类型</li>
<li>自动拆箱调用了 x.xxxValue()：将具体的包装类型对象转换成基本类型</li>
<li>缓存池</li>
</ol>
<blockquote>
<p>new Integer(123) 与 Integer.valueOf(123)的区别：</p>
<ul>
<li>前者每次都会新建一个对象</li>
<li>后者会优先使用缓存池中的对象，多次调用会取得同一个对象的引用</li>
<li>Java8中，Integer的缓存池的默认大小为-128~127，其中缓存上限可以在 jvm 中进行修改；最大不超过 Integer.MAX_VALUE - (-low) + 1</li>
<li>在使用基本类型（byte, short, char, int）对应的包装类的时候，如果数值范围在缓冲范围内，就可以直接使用缓冲池中的对象</li>
</ul>
</blockquote>
<h3 id="2-String"><a href="#2-String" class="headerlink" title="2.String"></a>2.String</h3><ol>
<li><strong>String 不可变的好处</strong></li>
</ol>
<ul>
<li>可以缓存 hash 值 ：因为 String 不可变，所以用作键的 String 对应的 hash 值也就不会变</li>
<li>String Pool 的需要<ul>
<li>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用</li>
</ul>
</li>
<li>安全性<ul>
<li>String 做参数，不可变性可以保证参数不可变</li>
</ul>
</li>
<li>线程安全<ul>
<li>可在多线程中使用</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>String, StringBuffer, StringBuilder</strong></li>
</ol>
<ul>
<li><strong>可变性</strong><ul>
<li>String 不可变</li>
<li>另外两个可变</li>
</ul>
</li>
<li><strong><em>线程安全</em></strong><ul>
<li>StringBuilder 不是线程安全的，性能高</li>
<li>StringBuffer 线程安全，性能相对较低，内部使用 synchronized 进行同步</li>
<li>如何选择？<ul>
<li>数据要求可变且应用只使用单线程时，使用 StringBuilder</li>
<li>数据要求可变且在多线程环境中时，使用 StringBuffer 来确保线程安全</li>
<li>数据不要求可变就使用 String</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>String Pool</strong></li>
</ol>
<p>​        字符串常量池保存着所有字符串字面量，这些字面量在编译时期就确定。可以使用 String 的 intern（）方法在运行过程中将字符串添加到 String Pool 中。</p>
<p>​        如果是采用“bbb”的这种字面量的形式创建字符串，自动放入字符串池。</p>
<hr>
<h3 id="3-运算"><a href="#3-运算" class="headerlink" title="3.运算"></a>3.运算</h3><ol>
<li><strong>参数传递</strong></li>
</ol>
<p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<ol start="2">
<li><strong>float 与 double</strong></li>
</ol>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1; // 1.1字面量属于double,不能直接将 1.1 赋值给 float 变量，因为这是向下转型</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;   <span class="comment">// 1.1f 才是 float 类型</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>隐式类型转换</strong></li>
</ol>
<p>因为字面量 1 是 int 类型，所以不能隐式将 int 类型向下转型为 short类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;  这个地方的字面量1是 int 类型</span></span><br></pre></td></tr></table></figure>

<p><strong>但是使用 += 或者 ++ 运算符可以执行隐式类型转换(+=，-=，*=，/=)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line"><span class="comment">// s1 ++;</span></span><br></pre></td></tr></table></figure>

<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1 = (<span class="keyword">short</span>)(s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h3><ol>
<li><strong>访问权限</strong>：对类或类中的成员（字段以及方法）加访问修饰符</li>
</ol>
<ul>
<li>private：当前类访问权限</li>
<li>default：包访问权限，同一个包下可以访问</li>
<li>protected：子类访问权限，<strong>通常希望子类重写这个方法</strong><ul>
<li><strong>重写原则</strong><ul>
<li>子类访问权限 ≥ 父类访问权限</li>
<li>子类方法返回值类型 ≤ 父类方法返回值类型</li>
<li>子类方法声明抛出的异常 ≤ 父类方法声明抛出的异常</li>
<li>子类重写方法通常使用 @Override 注解，从而让编译器自动检查是否满足限制条件</li>
</ul>
</li>
</ul>
</li>
<li>public：公共访问权限</li>
<li>设计原则：<ul>
<li>访问权限应当尽可能使每个类或者成员不被外界访问</li>
<li>字段不能是公有的，这样做的话就丧失了对这个字段修改行为的控制<ul>
<li>如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有太大的影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>抽象类与接口</strong></li>
</ol>
<ul>
<li><strong>比较</strong><ul>
<li><strong>设计层面：</strong>抽象类提供了一种 IS-A 关系，那么必须满足里氏替换原则，即子类对象必须能够替换掉所有父类对象；接口更像是一种 LIKE-A 关系，他只提供方法实现的约束，并不要求接口和实现接口的类具有 IS-A 的关系</li>
<li><strong>使用：</strong>一个类可以实现多个接口但是只能继承一个抽象类。可以将接口类似看做 java 不能实现多继承的妥协吧</li>
<li>接口的字段只能是 static 和 final 类型，抽象类没有要求</li>
<li>接口的成员只能是 public 的，抽象类的成员可以有多种访问权限。</li>
</ul>
</li>
<li><strong>使用选择</strong><ul>
<li>使用接口：<ul>
<li>让不想关的类都实现一个方法，如 Comparable 接口中的 compareTo（）方法</li>
<li>需要使用多重继承</li>
</ul>
</li>
<li>使用抽象类<ul>
<li>要在多个类中共享代码</li>
<li>需要控制继承来的成员的访问权限，而不是都为 public</li>
<li>需要继承非静态和非常量字段</li>
</ul>
</li>
<li>在多种情况下，接口由于抽象类，因为接口没有严格的类层次要求；从 Java 8 开始，接口可以有默认的方法实现了。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>super</strong></li>
</ol>
<ul>
<li>访问父类的构造函数</li>
<li>访问父类的成员</li>
</ul>
<ol start="4">
<li><strong>重写与重载</strong></li>
</ol>
<ul>
<li>重载：参数类型、个数、顺序至少有一个不同；<strong>返回值不同，其他都相同不算是重载</strong></li>
</ul>
<hr>
<h3 id="5-Object-通用方法"><a href="#5-Object-通用方法" class="headerlink" title="5.Object 通用方法"></a>5.Object 通用方法</h3><ol>
<li><strong>equals()</strong></li>
</ol>
<ul>
<li>等价关系：自反性、对称性、一致性、传递性，任何非空元素与 null 比较都为 false</li>
<li><strong>等价与相等</strong><ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals（）方法</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals（）判断引用的对象是否等价</li>
</ul>
</li>
<li><strong>实现举例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果不是同一个 .class 文件，那么肯定不相等</span></span><br><span class="line">        <span class="keyword">if</span>(o == <span class="keyword">null</span> &amp;&amp; getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 需要将 o 强制类型转换为 EqualExample</span></span><br><span class="line">        EqualExample other = (EqualExample) o;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x != other.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(y != other.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == other.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>hashCode()</strong></li>
</ol>
<ul>
<li>hashCode() 返回散列值，equals() 用来判断两个对象是否等价。</li>
<li><strong>等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</strong></li>
<li><strong>在覆盖 equals() 方法时，应当总是覆盖 hashCode() 方法，保证等价的两个对象的散列值也相等。</strong></li>
</ul>
<ol start="3">
<li><strong>toString()</strong></li>
</ol>
<ul>
<li>默认返回     <strong>类名@散列码的无符号十六进制</strong></li>
</ul>
<ol start="4">
<li><strong>clone()</strong></li>
</ol>
<ul>
<li><p><strong>cloneable</strong></p>
<ul>
<li>clone() 是 Object 的 protected 方法，要是一个类不显示去重写 clone() ，其他类就不能直接去调用该类实例的 clone() 方法。</li>
<li>要想重写 clone() 方法，首先<strong>这个类要实现 Cloneable 接口，这个接口只是一个规定</strong>，否则程序抛出 CloneNotSupportedException</li>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 Object 类里面的 clone() 方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>浅拷贝</strong></p>
</li>
</ul>
<blockquote>
<p>拷贝对象和原始对象的引用类型      引用同一个对象</p>
</blockquote>
<p><strong>当原始对象发生了改变，则拷贝对象也要发生改变。反之亦然</strong></p>
<ul>
<li><strong>深拷贝</strong></li>
</ul>
<blockquote>
<p>拷贝对象和原始对象的引用类型       引用不同对象</p>
</blockquote>
<p><strong>原始对象改变不影响拷贝对象，可以看做两者不再相关。</strong></p>
<ul>
<li><strong>clone() 的替代方案</strong></li>
</ul>
<p>最好不要使用 clone() ，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。功效同深拷贝</p>
<hr>
<h3 id="6-关键字"><a href="#6-关键字" class="headerlink" title="6.关键字"></a>6.关键字</h3><ol>
<li><strong>final</strong></li>
</ol>
<ul>
<li><p><strong>数据：声明数据为常量</strong></p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其他对象，<strong>但是被引用的对象本身是可以修改的。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// y = new A(); 这个就是非法的了，因为new 相当于让 y 重新引用其他对象，这样就不行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法：声明方法不能被子类重写</strong></p>
<ul>
<li>private 方法隐式地被指定为 final，<strong>如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法</strong></li>
</ul>
</li>
<li><p><strong>类：声明类不允许被继承</strong></p>
</li>
</ul>
<ol start="2">
<li><strong>static</strong></li>
</ol>
<ul>
<li><p>*<em>静态变量 *</em></p>
<ul>
<li>又称“类变量”，在内存中只存在一份。</li>
<li>每创建一个实例就会产生一个实例变量，他与该实例同生共死。</li>
</ul>
</li>
<li><p><strong>静态方法</strong></p>
<ul>
<li>在类加载的时候就存在了，不依赖于任何实例。故静态方法不能是抽象方法，必须有实现。</li>
<li>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字；<ul>
<li>因为在类加载的时候，还没有任何实例，只有类的静态属性存在，所以智能访问静态字段和静态方法</li>
<li>因为在类加载的时候，还没有任何实例，所以也就不存在 this 和 super 。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>静态语句块</strong></p>
<ul>
<li>在类初始化时运行一次；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态内部类</strong></p>
<ul>
<li>非静态内部类依赖于外部实例，而静态内部类不需要</li>
<li>静态内部类不能访问外部类的非静态变量和方法，原因同静态方法中的描述</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context</span></span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        <span class="comment">// 非静态内部类依赖于外部类的实例</span></span><br><span class="line">        <span class="comment">// 所以需要先实例化外部类  在实例化内部类</span></span><br><span class="line">        <span class="comment">// outerClass.new InnerClass()</span></span><br><span class="line">        InnerClass innerClass = outerClass.new InnerClass();</span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态导包</strong></p>
<ul>
<li>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化顺序</strong></p>
<ul>
<li>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于代码中的顺序。</li>
<li>存在继承的情况下，初始化顺序为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父类（静态变量、静态代码块）</span><br><span class="line">子类（静态变量、静态代码块）</span><br><span class="line">父类（实例变量、普通语句块）</span><br><span class="line">父类（构造函数）</span><br><span class="line">子类（实例变量、普通语句块）</span><br><span class="line">子类（构造函数）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="7-反射"><a href="#7-反射" class="headerlink" title="7.反射"></a>7.反射</h3><blockquote>
<p><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">深入解析 Java 反射 （1）- 基础</a></p>
</blockquote>
<ol>
<li>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：<ul>
<li><strong>Filed：</strong>可以使用 get() 和 set() 方法读取和修改 Filed 对象关联的字段；</li>
<li><strong>Method：</strong>可以使用 invoke() 方法调用与 Method() 对象关联的方法；</li>
<li><strong>Constructor：</strong>可以使用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
</li>
<li><strong>反射的优点</strong><ul>
<li><strong>可扩展性：</strong>应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong></li>
<li><strong>调试器和测试工具</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>性能开销</li>
<li>安全限制</li>
<li>内部暴露</li>
</ul>
</li>
</ol>
<hr>
<h3 id="8-异常"><a href="#8-异常" class="headerlink" title="8.异常"></a>8.异常</h3><ol>
<li>Throwable 可用来表示任何可以作为异常抛出的类，分为两种：<strong>Error</strong> 和 <strong>Exception</strong>。其中 <strong>Error</strong> 表示 JVM 无法处理的错误，<strong>Exception</strong> 又分为两种<ul>
<li><strong>受检异常：</strong>需要使用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常：</strong>程序运行时错误，程序奔溃且无法恢复。如 Arithmetic Exception</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yxin185/picGo/master/img7-15/PPjwP.png" alt></p>
<hr>
<h3 id="9-泛型"><a href="#9-泛型" class="headerlink" title="9.泛型"></a>9.泛型</h3><blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1033693" target="_blank" rel="noopener">10道 Java 泛型面试题</a></p>
</blockquote>
<ul>
<li><p><strong>Java 中的泛型是什么？使用泛型的好处是什么？</strong></p>
<ul>
<li>泛型避免了在集合中存储对象并在使用前进行类型转换带来的不变，它提供了<strong>编译期的类型安全</strong>，确保我们只能把正确类型的对象放入集合中，避免在运行时出现 <strong>ClassCastException</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该 list 对象只能存储类型为 String 的元素</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 的泛型是如何工作的？什么是类型擦除？</strong></p>
</li>
<li><p><strong>什么是泛型中的限定通配符和非限定通配符？</strong></p>
</li>
<li><p><strong>List&lt;? extends T&gt; 和 List&lt;? super T&gt; 之间有什么区别？</strong></p>
</li>
<li><p><strong>如何编写一个泛型方法，让它能够接受泛型参数并返回泛型类型？</strong></p>
</li>
<li><p><strong>Java 中如何使用泛型编写带有参数的类？</strong></p>
</li>
<li><p><strong>Array 中可以使用泛型吗？</strong></p>
</li>
<li><p><strong>如何阻止 Java 中的类型未检查的警告？</strong></p>
</li>
</ul>
<hr>
<h3 id="10-注解"><a href="#10-注解" class="headerlink" title="10.注解"></a>10.注解</h3>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转数据结构</title>
    <url>/2019/09/18/%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
    <content><![CDATA[<p>学习数据结构与算法ing.</p>
<a id="more"></a>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li>数组队列出队操作O(n)，循环队列出队为O(1)。对于数组队列而言，出队操作之后，需要将后续元素全部向前移动一个位置，所以为O(n)；循环队列多维护一个队列头，省去位置移动操作，所以为O(1).</li>
<li>循环队列的入队操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tail指的是下一次能够插入元素的位置，而不是目前最后一个元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 说明这个循环队列元素已经存满(其实还留有一个位置，这个位置就空着)</span></span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % data.length == front) &#123;</span><br><span class="line">            resize(getCapacity() * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[tail] = e;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % data.length;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数组队列：出队相当于在数组头删除元素后所有元素向前进，入队直接在数组末尾添加元素即可。</li>
<li>循环队列的出队操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot dequeue from a empty queue."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        E ret = data[front];</span><br><span class="line">        data[front] = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">// 将头指针向后移动一个位置，因为是循环的，考虑到头指针要是在数组尾部，则需要</span></span><br><span class="line">    	<span class="comment">// 模一个数组长度来将头指针移动</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % data.length;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (size == getCapacity() / <span class="number">4</span> &amp;&amp; getCapacity() / <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            resize(getCapacity() / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>动态数组其实就是当数组满的时候，编写一个方法，将当前数组的容量扩大为原有的2倍(或者其他倍)</li>
</ol>
<hr>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol>
<li>给链表设置一个虚拟头结点有利于链表的操作。虚拟头结点就是链表第一个元素之前的一个假想的节点。</li>
<li>基于链表的队列维护一个头指针和尾指针是有必要的。</li>
<li>基于链表的队列：出队</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尾结点插入为O(1),删除为O(n)</span></span><br><span class="line">	<span class="comment">// 要从尾结点删除一个元素，需要首先遍历到尾结点的前一个节点，时间复杂度为O(n)</span></span><br><span class="line">    <span class="comment">// 所以尾结点为队列头，头结点为队列尾</span></span><br><span class="line">    <span class="comment">// 从tail端插入元素，从head端删除元素</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot dequeue from a empty queue."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node delNode = head;</span><br><span class="line">    head = head.next; <span class="comment">// 头指针后移</span></span><br><span class="line">    delNode.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size --;</span><br><span class="line">    <span class="keyword">return</span> delNode.e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>基于链表的队列：入队</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此时队列也空</span></span><br><span class="line">        tail = <span class="keyword">new</span> Node(e);</span><br><span class="line">        head = tail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tail.next = <span class="keyword">new</span> Node(e);</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    size ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>基于链表的栈：入栈在头结点进行，复杂度为O(1)</li>
<li>ArrayList 基于数组，LinkedList 基于双向链表（记录前后元素的指针）<ol>
<li>对于随机访问元素，ArrayList 更好</li>
<li>对于插入删除元素，LinkedList更优</li>
</ol>
</li>
</ol>
<hr>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ol>
<li>栈和队列都可以用数组或者链表来底层实现</li>
<li>关键是搞清楚定义，然后选择时间复杂度最小的方式来实现就行</li>
<li>栈：先入后出</li>
<li>队列：先入先出</li>
</ol>
<hr>
<h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><ol>
<li>因为二分搜索树需要比较的性质，所以在定义类时，泛型要继承Comparable接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>向二分搜索树中添加元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        root = add(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回插入新节点后二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 划分为更小的问题</span></span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将左子树根节点作为新的根节点，在上面添加元素e</span></span><br><span class="line">            node.left = add(node.left, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node.right = add(node.right, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>二分搜索树的前中后序遍历，递归非递归方法实现。</li>
<li>前序递归与非递归</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历:递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历:非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node curr = stack.pop();</span><br><span class="line">        System.out.println(curr.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(curr.right);</span><br><span class="line">        <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(curr.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>中序遍历递归与非递归</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历：结果是顺序的,以node为根的二分搜索树，递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     inOrder(root);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     inOrder(node.left);</span><br><span class="line">     System.out.println(node.e);</span><br><span class="line">     inOrder(node.right);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 中序非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     Node curr = root;</span><br><span class="line">     <span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">             stack.push(curr);</span><br><span class="line">             curr = curr.left;</span><br><span class="line">         &#125;</span><br><span class="line">         curr = stack.pop();</span><br><span class="line">         System.out.println(curr.e);</span><br><span class="line">         curr = curr.right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>后续递归与非递归</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历:为二分搜索树释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    System.out.println(node.e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历:非递归。和前序遍历有相似</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node curr = stack.pop();</span><br><span class="line">        list.add(curr.e);</span><br><span class="line">        <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(curr.left);</span><br><span class="line">        <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>层序遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        Node curr = q.remove();</span><br><span class="line">        System.out.println(curr.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>)</span><br><span class="line">            q.add(curr.left);</span><br><span class="line">        <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>)</span><br><span class="line">            q.add(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最大堆与优先队列"><a href="#最大堆与优先队列" class="headerlink" title="最大堆与优先队列"></a>最大堆与优先队列</h3><ol>
<li>二叉堆：是一棵完全二叉树</li>
<li>最大堆：堆中某节点的值总是不大于其父节点的值，底层用数组实现</li>
<li>若最大堆索引从0开始，则</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以i为索引值</span></span><br><span class="line">parent(i) = (i - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">// 索引为i的父亲节点的索引值</span></span><br><span class="line">leftChild(i) = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">rightChild(i) = <span class="number">2</span> * i + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>若最大堆索引从1开始，则</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以i为索引值</span></span><br><span class="line">parent(i) = i / <span class="number">2</span>;<span class="comment">// 索引为i的父亲节点的索引值</span></span><br><span class="line">leftChild(i) = <span class="number">2</span> * i ;</span><br><span class="line">rightChild(i) = <span class="number">2</span> * i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加元素后，可能改变最大堆的性质，执行siftUp操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较这个索引K对应的节点与其父节点的数据大小</span></span><br><span class="line">    <span class="comment">// 如果父亲节点的值小于该节点，则进行位置交换</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        data.swap(parent(k),k);</span><br><span class="line">        k = parent(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>从堆中取出最大元素后，破坏了最大堆的性质，重调结构</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(log n)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 说明这个索引还有左孩子节点</span></span><br><span class="line">    <span class="keyword">while</span> (leftChild(k) &lt; data.getSize()) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = leftChild(k);</span><br><span class="line">        <span class="comment">// 存在右孩子节点并且右孩子节点比当前节点大</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; data.getSize() &amp;&amp;</span><br><span class="line">                data.get(j + <span class="number">1</span>).compareTo(data.get(j)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            j = rightChild(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// data[j]是leftChild和rightChild中的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (data.get(k).compareTo(data.get(j)) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        data.swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>使用最大堆实现优先队列</li>
<li>优先队列的经典问题</li>
</ol>
<blockquote>
<p>在N个元素中选出前M个元素</p>
<p>排序    =&gt;  O(N log N)</p>
<p>优先队列    =&gt;  O(N log M)</p>
</blockquote>
<ol start="9">
<li>优先队列</li>
</ol>
<table>
<thead>
<tr>
<th align="center">优先队列</th>
<th align="center">入队</th>
<th align="center">出队（拿出最大元素）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通线性结构</td>
<td align="center">O(1)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">顺序线性结构</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">O(log n)</td>
<td align="center">O(log n)</td>
</tr>
</tbody></table>
<ol start="10">
<li>将给定的一个数组转换为一个最大堆，使用heapify方法 =&gt; O(n)，要是使用传统的将元素一个一个插入到堆中的复杂度为O(n long n)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MaxHeap</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">    data = <span class="keyword">new</span> MyArray&lt;&gt;(arr);</span><br><span class="line">    <span class="comment">// 实现heapify过程</span></span><br><span class="line">    <span class="comment">// 从索引为最后一个非叶子节点开始，依次执行下沉siftDown操作</span></span><br><span class="line">    <span class="comment">// 对索引为0的节点也要执行下沉操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = parent(arr.length - <span class="number">1</span>);i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><blockquote>
<p>每一个树节点代表一个区间；解决的经典问题：区间染色问题</p>
<p>线段树：不考虑添加删除操作，线段树的区间是固定的，只是区间元素发生改变</p>
<p>如果区间有n个元素，数组需要有4n个静态空间</p>
</blockquote>
<ol>
<li>线段树不是完全二叉树</li>
<li>计算两个整形的中间值，为避免整形溢出：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// l:左端点</span></span><br><span class="line"><span class="comment">// r:右端点</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><blockquote>
<p>只用于处理字符串</p>
<p>查询条目的时间复杂度与字典中总条目数无关，时间为O(w),w为查询单词的长度</p>
</blockquote>
<hr>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote>
<p>解决连接问题，网络中节点的连接问题</p>
<p>主要支持两个动作</p>
<ul>
<li>unionElements(int p,int q); // 将索引为p和q的两个元素放到一个组</li>
<li>isConnected(int p,int q); // 判断索引为p和q的两个元素是否相连接</li>
</ul>
</blockquote>
<ol>
<li>V1：Quick Find 查询时间复杂度低；<strong>查：O(1), 并：O(n)</strong><ul>
<li>索引为p的元素的集合编号就是id[p]；</li>
</ul>
</li>
<li>V2：一棵由孩子指向父亲的树；<strong>查：O(h),h为树高；并：O(h)</strong></li>
<li>V3：根据每一个根节点所包含的节点数来优化这棵树；<strong>查：O(h),h为树高；并：O(h)</strong>。基于V2改进<ul>
<li>把短的节点连接到长的节点上面去，用size记录树节点的元素个数</li>
</ul>
</li>
<li>V4：基于V3改进，基于rank-树的高度进行优化<ul>
<li>把短的直接接到长的根节点上面，进一步减少了树的高度，用rank记录树的高度</li>
</ul>
</li>
<li>V5：路径压缩 path compressing；基于V4的优化<ul>
<li>路径压缩的操作主要与V4的差别在于find函数中，在查找节点根节点的过程中顺便压缩树的高度</li>
<li>时间复杂度为O(log *n) ，快于O(log n)，近乎O(1)</li>
</ul>
</li>
</ol>
<hr>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><blockquote>
<p>第一个支持自平衡的树结构</p>
<p>基于二分搜索树</p>
<p>是一个平衡二叉树：对任意一个节点，他的左右孩子节点的高度差小于等于1</p>
<p>高度与节点数目关系 h = O(log n)</p>
</blockquote>
<hr>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><hr>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3>]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
